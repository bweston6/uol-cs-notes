I"Žç
<h1 id="comp105---lecture-19-2"><a href="/UoL/comp105/lectures/2020/11/23/2.html">COMP105 - Lecture 19-2</a></h1>
<h2 id="more-complex-custom-types">More Complex Custom Types</h2>
<h3 id="more-complex-constructors">More Complex Constructors</h3>
<p>More complex constructors can contain other types.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Point</span> <span class="o">=</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</code></pre></div></div>

<p>This is saying that the type <code class="language-plaintext highlighter-rouge">Point</code> has one constructor called <code class="language-plaintext highlighter-rouge">Point</code> and in that constructor there are two <code class="language-plaintext highlighter-rouge">Int</code>. The constructor name has no relation to the type name.</p>

<p class="info">It is common that if your type has only one constructor to call constructor the same name as the type.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Point</span> <span class="mi">1</span> <span class="mi">4</span>
<span class="o">&gt;</span> <span class="kt">Point</span> <span class="mi">1</span> <span class="mi">4</span>

<span class="o">&gt;</span> <span class="n">read</span> <span class="s">"Point 10 10"</span> <span class="o">:</span> <span class="kt">Point</span>
<span class="o">&gt;</span> <span class="kt">Point</span> <span class="mi">10</span> <span class="mi">10</span>

<span class="o">&gt;</span> <span class="kt">Point</span> <span class="mi">2</span> <span class="mi">2</span> <span class="o">/=</span> <span class="kt">Point</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="kt">True</span>
</code></pre></div></div>

<p>It is also common to use pattern matching to work with complex constructors:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shift_up</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Point</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">shift_up</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="kt">Point</span> <span class="mi">1</span> <span class="mi">2</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">shift_up</span>
<span class="o">&gt;</span> <span class="n">shift_up</span> <span class="o">::</span> <span class="kt">Point</span> <span class="o">-&gt;</span> <span class="kt">Point</span>
</code></pre></div></div>

<h4 id="example">Example</h4>
<p>This example completes a computation using almost entirely our own custom types. We are also using pattern matching on our types:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">move</span> <span class="o">::</span> <span class="kt">Point</span> <span class="o">-&gt;</span> <span class="kt">Direction</span> <span class="o">-&gt;</span> <span class="kt">Point</span>

<span class="n">move</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="kt">North</span> <span class="o">=</span> <span class="kt">Point</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">move</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="kt">South</span> <span class="o">=</span> <span class="kt">Point</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">move</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="kt">East</span> <span class="o">=</span> <span class="kt">Point</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">y</span>
<span class="n">move</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="kt">West</span> <span class="o">=</span> <span class="kt">Point</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">y</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">move</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="kt">North</span>
<span class="o">&gt;</span> <span class="kt">Point</span> <span class="mi">0</span> <span class="mi">1</span>
</code></pre></div></div>

<h3 id="more-complex-constructors-continued">More Complex Constructors Continued</h3>
<p>Types can have multiple constructors each of which can have their own types:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Shape</span> <span class="o">=</span> <span class="n">circle</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rect</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Circle</span> <span class="mf">2.0</span>
<span class="o">&gt;</span> <span class="kt">Circle</span> <span class="mf">2.0</span> <span class="o">::</span> <span class="kt">Shape</span>

<span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="kt">Rect</span> <span class="mf">3.0</span> <span class="mf">4.0</span>
<span class="o">&gt;</span> <span class="kt">Rect</span> <span class="mf">3.0</span> <span class="mf">4.0</span> <span class="o">::</span> <span class="kt">Shape</span>
</code></pre></div></div>

<h4 id="example-1">Example</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">area</span> <span class="o">::</span> <span class="kt">Shape</span> <span class="o">-&gt;</span> <span class="kt">Float</span>

<span class="n">area</span> <span class="p">(</span><span class="kt">Circle</span> <span class="n">radius</span><span class="p">)</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">area</span> <span class="p">(</span><span class="kt">Rect</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">area</span> <span class="p">(</span><span class="kt">Circle</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mf">12.56371</span>

<span class="o">&gt;</span> <span class="n">area</span> <span class="p">(</span><span class="kt">Rect</span> <span class="mf">3.0</span> <span class="mf">4.0</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mf">12.0</span>
</code></pre></div></div>

<h3 id="records">Records</h3>
<p>You can use data types to build custom records:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kt">String</span>

<span class="n">get_first_name</span>	<span class="p">(</span><span class="kt">Person</span> <span class="n">x</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">get_second_name</span>	<span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="n">x</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">get_age</span>		<span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">x</span> <span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">get_nationality</span>	<span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">get_age</span> <span class="p">(</span><span class="kt">Person</span> <span class="s">"joe"</span> <span class="s">"bloggs"</span> <span class="mi">25</span> <span class="s">"UK"</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mi">25</span>
</code></pre></div></div>

<h4 id="record-syntax">Record Syntax</h4>
<p>To make things easier, Haskell provides a record syntax:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Person</span> <span class="o">=</span> <span class="kt">Person</span> <span class="p">{</span>	<span class="n">firstName</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span>
			<span class="n">secondName</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span>
			<span class="n">age</span> <span class="o">::</span> <span class="kt">Int</span><span class="p">,</span>
			<span class="kt">Nationality</span> <span class="o">::</span> <span class="kt">String</span><span class="p">}</span>
			<span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Person</span> <span class="s">"joe"</span> <span class="s">"bloggs"</span> <span class="mi">25</span> <span class="s">"UK"</span>
<span class="o">&gt;</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="o">=</span> <span class="s">"joe"</span><span class="p">,</span> <span class="n">secondName</span> <span class="o">=</span> <span class="s">"bloggs"</span><span class="p">,</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">25</span><span class="p">,</span> <span class="n">nationality</span> <span class="o">=</span> <span class="s">"UK"</span><span class="p">}</span>
</code></pre></div></div>

<p>This is similar to the previous example where we made our own record type.</p>

<p>Records can be created out of order, whereas normal data types cannot.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Example</span> <span class="o">=</span> <span class="kt">Example</span> <span class="p">{</span><span class="n">a</span> <span class="o">::</span> <span class="kt">String</span><span class="p">,</span>
						<span class="n">b</span> <span class="o">::</span> <span class="kt">Int</span><span class="p">}</span>
						<span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kt">Example</span> <span class="s">"one"</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="kt">Example</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="s">"one"</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">}</span>

<span class="o">&gt;</span> <span class="kt">Example</span> <span class="p">{</span><span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"zero"</span><span class="p">}</span>
<span class="o">&gt;</span> <span class="kt">Example</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="s">"zero"</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<p>If you create an out of order function then you should put them in <code class="language-plaintext highlighter-rouge">{}</code> with their labels so that Haskell  can identify them.</p>

<h3 id="example-2">Example</h3>
<p>This example takes a co-ordinate <code class="language-plaintext highlighter-rouge">Point</code> to locate the shape in 2D space.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">AdvShape</span> <span class="o">=</span> <span class="kt">AdvCircle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">AdvRect</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="n">area'</span> <span class="p">(</span><span class="kt">AdvCircle</span> <span class="kr">_</span> <span class="n">radius</span><span class="p">)</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">area'</span> <span class="p">(</span><span class="kt">AdvRect</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="o">=</span>
	<span class="kr">let</span>
		<span class="n">w</span> <span class="o">=</span> <span class="n">abs</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span>
		<span class="n">h</span> <span class="o">=</span> <span class="n">abs</span> <span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span>
	<span class="kr">in</span>
		<span class="n">fromIntergral</span> <span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kr">data</span> <span class="kt">Point</span> <span class="o">=</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
 <span class="n">distance</span> <span class="o">::</span> <span class="kt">Point</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
 <span class="n">distance</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kr">data</span> <span class="kt">HTTPResponse</span> 	<span class="o">=</span> <span class="kt">Data</span> <span class="kt">Int</span> <span class="kt">String</span> 
             <span class="o">|</span> <span class="kt">Error</span> <span class="kt">String</span>
             <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kr">data</span> <span class="kt">Student</span> <span class="o">=</span> <span class="kt">Student</span> <span class="p">{</span><span class="n">name</span> <span class="o">::</span> <span class="kt">String</span>
             <span class="n">address</span> <span class="o">::</span> <span class="kt">String</span>
             <span class="n">marks</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
             <span class="p">}</span>
             <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-19-1"><a href="/UoL/comp105/lectures/2020/11/23/1.html">COMP105 - Lecture 19-1</a></h1>
<h2 id="custom-types">Custom Types</h2>
<p>There are two ways to make types in Haskell.</p>

<h3 id="the-type-keyword">The <code class="language-plaintext highlighter-rouge">type</code> Keyword</h3>
<p>The <code class="language-plaintext highlighter-rouge">type</code> keyword gives a new name to an existing type.</p>

<ul>
  <li>All types must start with capital letters.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">String'</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>

<span class="n">exclaim</span> <span class="o">::</span> <span class="kt">String'</span> <span class="o">-&gt;</span> <span class="kt">String'</span>
<span class="n">exclaim</span> <span class="n">str</span> <span class="o">=</span> <span class="n">str</span> <span class="o">+</span> <span class="s">"!"</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">exclaim</span> <span class="s">"hello"</span>
<span class="o">&gt;</span> <span class="s">"hello!!
</span></code></pre></div></div>

<p>Type is useful when you want to give a meaningful name to a complex type.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">VoteResults</span> <span class="o">=</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span>

<span class="n">results</span> <span class="o">::</span> <span class="kt">VoteResults</span>
</code></pre></div></div>

<h3 id="the-data-keyword">The <code class="language-plaintext highlighter-rouge">data</code> Keyword</h3>
<p>The <code class="language-plaintext highlighter-rouge">data</code> keyword is used to create an entirely  new type.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Bool'</span> <span class="o">=</span> <span class="kt">True</span> <span class="o">|</span> <span class="kt">False</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">|</code> should be read as OR.</li>
  <li>Each of the values is a constructor.
    <ul>
      <li>Each constructor should start with a capital letter.</li>
    </ul>
  </li>
</ul>

<p class="info">To find out more about a type you can use the GHCI <code class="language-plaintext highlighter-rouge">:info</code> command. For more information about a type constructor then you can use the <code class="language-plaintext highlighter-rouge">type</code> command.</p>

<h4 id="example">Example</h4>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Direction</span> <span class="o">=</span> <span class="kt">North</span> <span class="o">|</span> <span class="kt">South</span> <span class="o">|</span> <span class="kt">East</span> <span class="o">|</span> <span class="kt">West</span>

<span class="n">rotate</span> <span class="kt">North</span> <span class="o">=</span> <span class="kt">East</span>
<span class="n">rotate</span> <span class="kt">East</span> <span class="o">=</span> <span class="kt">South</span>
<span class="n">rotate</span> <span class="kt">South</span> <span class="o">=</span> <span class="kt">West</span>
<span class="n">rotate</span> <span class="kt">West</span> <span class="o">=</span> <span class="kt">North</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">rotate</span>
<span class="o">&gt;</span> <span class="n">rotate</span> <span class="o">::</span> <span class="kt">Direction</span> <span class="o">-&gt;</span> <span class="kt">Direction</span>
</code></pre></div></div>

<h3 id="type-classes">Type Classes</h3>
<p>By default, a new data type is not part of any type class. This means that running <code class="language-plaintext highlighter-rouge">rotate</code> will give an error. As is GHCI doesnâ€™t know how to <code class="language-plaintext highlighter-rouge">show</code> it.</p>

<p>We can use the <code class="language-plaintext highlighter-rouge">deriving</code> keyword to fix this:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Direction</span> <span class="o">=</span> <span class="kt">North</span> <span class="o">|</span> <span class="kt">South</span> <span class="o">|</span> <span class="kt">East</span> <span class="o">|</span> <span class="kt">West</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</code></pre></div></div>

<p>This will automatically put the type into the class <code class="language-plaintext highlighter-rouge">Show</code> and will allow it to print to the prompt.</p>

<p>Hakell can automatically implement the following type classes:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Show</code>
    <ul>
      <li>Will print out the type as it is in the code.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Read</code>
    <ul>
      <li>Will parse the type as it is in the code.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Eq</code>
    <ul>
      <li>The natural definition of equality.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">Ord</code>
    <ul>
      <li>Constructors that come first are smaller.</li>
    </ul>
  </li>
</ul>

<p>You can add these to the tuple that deriving takes as input. You should include all type classes that make sense for your type so that you can use the functions you want.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">type Marks = (String, [Int])</code></li>
  <li><code class="language-plaintext highlighter-rouge">data Colour = Red | Blue | Green deriving (Show, Read)</code></li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">toRGB</span> <span class="o">::</span> <span class="kt">Colour</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Float</span><span class="p">,</span> <span class="kt">Float</span><span class="p">,</span> <span class="kt">Float</span><span class="p">)</span>
 <span class="n">toRGB</span> <span class="kt">Red</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
 <span class="n">toRGB</span> <span class="kt">Green</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
 <span class="n">toRGB</span> <span class="kt">Blue</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>    </div>

    <p class="warning">You should note that as this type isnâ€™t in the class <code class="language-plaintext highlighter-rouge">eq</code> then you canâ€™t use guard and equality testing on it.</p>
  </li>
</ol>

<h1 id="comp105---lecture-18-2"><a href="/UoL/comp105/lectures/2020/11/19/2.html">COMP105 - Lecture 18-2</a></h1>
<h2 id="first-past-the-post-example">First Past the Post Example</h2>
<p>This example covers a first past the post election. This means whoever gets the most votes wins. We are aiming to make a function that performs this task:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">winner</span> <span class="p">[</span><span class="s">"red"</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="s">"red"</span>
</code></pre></div></div>

<h3 id="getting-the-candidates">Getting the Candidates</h3>
<p>First we need to figure out who the candidates are:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">uniq</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">uniq</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">uniq</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">/=</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span> <span class="p">)</span>
</code></pre></div></div>

<p>This function will remove duplicates from a list of strings. For every new element found the filter will remove all further occurrences from the rest of the list before recursing on the list.</p>

<h3 id="counting-the-votes">Counting the Votes</h3>
<p>This function counts the number of votes for a particular  candidate:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">count</span> <span class="n">x</span> <span class="n">list</span> <span class="o">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">==</span><span class="n">x</span><span class="p">)</span> <span class="n">list</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="vote-totals">Vote Totals</h3>
<p>This function will count all the votes for each candidate and put the number of votes and then the candidate in a list of tuples.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">total</span> <span class="n">votes</span> <span class="o">=</span> 
	<span class="kr">let</span>
		<span class="n">candidates</span> <span class="o">=</span> <span class="n">uniq</span> <span class="n">votes</span>
		<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">count</span> <span class="n">c</span> <span class="n">votes</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
	<span class="kr">in</span>
		<span class="n">map</span> <span class="n">f</span> <span class="n">candidates</span>
</code></pre></div></div>

<h3 id="comparing-candidates">Comparing Candidates</h3>
<p>Tuples are compared lexicographically. This means that each element is compared in turn to find which satisfies the function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">max</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"red"</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">"red"</span><span class="p">)</span>
</code></pre></div></div>

<p>This means that if two candidates have the same number then the string is compared.</p>

<h4 id="maximum"><code class="language-plaintext highlighter-rouge">maximum</code></h4>
<p>The function <code class="language-plaintext highlighter-rouge">maximum</code> takes a list and returns the largest item in the list:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"red"</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">"green"</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">"green"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="finding-the-winner">Finding the Winner</h3>
<p><code class="language-plaintext highlighter-rouge">snd</code> returns the second value in a tuple:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">winner</span> <span class="n">votes</span> <span class="o">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">maximum</span> <span class="o">.</span> <span class="n">totals</span> <span class="o">$</span> <span class="n">votes</span>
</code></pre></div></div>

<p>Applying this satisfies the requirement:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">winner</span> <span class="p">[</span><span class="s">"red"</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="s">"red"</span>
</code></pre></div></div>

<h2 id="alternative-vote-example">Alternative Vote Example</h2>
<p>In the alternative vote system, voters rank the candidates:</p>

<ul>
  <li>In each round, the candidate with the least number of first preference votes is eliminated.</li>
  <li>The winner is the last candidate left once all other have been eliminated.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">votes</span> <span class="o">=</span> <span class="p">[[</span><span class="s">"red"</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">],</span>
				<span class="p">[</span><span class="s">"blue"</span><span class="p">,</span> <span class="s">"green"</span><span class="p">],</span>
				<span class="p">[</span><span class="s">"green"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">],</span>
				<span class="p">[</span><span class="s">"blue"</span><span class="p">,</span> <span class="s">"red"</span><span class="p">],</span>
				<span class="p">[</span><span class="s">"red"</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="n">av_winner</span> <span class="n">votes</span>
<span class="o">&gt;</span> <span class="s">"red"</span>
</code></pre></div></div>

<p>You donâ€™t need many preferences and each list is a single personâ€™s preferences.</p>

<p class="info">See <a href="/UoL/assets/COMP105/Lectures/2020-11-19-2.pdf">the slides</a> for full examples.</p>

<h3 id="ranking-the-candidates">Ranking the Candidates</h3>
<p><code class="language-plaintext highlighter-rouge">sort</code> sorts all of the items in a list and orders them from smallest to biggest.</p>

<h3 id="getting-the-first-choice-votes">Getting the First Choice Votes</h3>
<p><code class="language-plaintext highlighter-rouge">head</code> doesnâ€™t accept empty lists as input. This should be taken into account when removing items from lists unevenly.</p>

<h3 id="final-function">Final Function</h3>
<p>All of the components give this function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">av_winner</span> <span class="n">votes</span> <span class="o">=</span>
	<span class="kr">let</span>
		<span class="n">ranked</span> <span class="o">=</span> <span class="n">rank_candidates</span> <span class="n">votes</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">head</span> <span class="n">ranked</span>
	<span class="kr">in</span>
		<span class="kr">if</span> <span class="n">length</span> <span class="n">ranked</span> <span class="o">==</span> <span class="mi">1</span>
		<span class="kr">then</span> <span class="n">first</span>
		<span class="kr">else</span> <span class="n">av_winner</span> <span class="p">(</span><span class="n">remove_cand</span> <span class="n">first</span> <span class="n">votes</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="comp105---lecture-18-1"><a href="/UoL/comp105/lectures/2020/11/19/1.html">COMP105 - Lecture 18-1</a></h1>
<h2 id="marks-to-report-example">Marks to Report Example</h2>
<p>This lecture covers a mini assignment example about converting a csv file containing students marks into a report containing the students averages. These are presented in the following format:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aaa		70	65	67	60
bbb		55	60	55	65
ccc		40	40	40	40
ddd		80	60	75	60
ccc		0	0	0	100
</code></pre></div></div>

<p>And should be transformed to be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aaa		65.5
bbb		58.75
ccc		40.0
ddd		68.75
ccc		25.0
</code></pre></div></div>

<p class="info">See <a href="/UoL/assets/COMP105/Lectures/2020-11-19-1.pdf">the slides</a> for the full examples.</p>

<h3 id="reading-files-in-haskell">Reading files in Haskell</h3>
<p>We can read a file using <code class="language-plaintext highlighter-rouge">readFile</code>:</p>

<ul>
  <li>This is an IO function.</li>
  <li>We will study this in more detail later on.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">readfile</span> <span class="s">"marks.csv"</span>
<span class="o">&gt;</span> <span class="s">"aaa		70	65	67	60</span><span class="se">\n</span><span class="s">bbb		55	60	55...
</span></code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">\n</code> character is the newline character.</p>

<h3 id="lines"><code class="language-plaintext highlighter-rouge">lines</code></h3>
<p>The lines function takes a string containing multiple lines into a list of strings. The complement to this function is the function <code class="language-plaintext highlighter-rouge">unlines</code>. This will do the opposite.</p>

<h3 id="parsing-the-file">Parsing the File</h3>
<p>Using the functions <code class="language-plaintext highlighter-rouge">words</code> and <code class="language-plaintext highlighter-rouge">lines</code> we can put the file into a list of lists of strings, in order to process the file.</p>

<h3 id="getting-the-averages">Getting the Averages</h3>
<p>The function <code class="language-plaintext highlighter-rouge">read</code> will convert a string into a float.</p>

<h3 id="writing-the-output-file">Writing the Output File</h3>
<p>The function <code class="language-plaintext highlighter-rouge">writeFile</code> will write some data into a file:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">writeFile</span> <span class="s">"test.txt"</span> <span class="s">"hello"</span>
</code></pre></div></div>

<p>This is not a pure function and we will see it again later.</p>

<h3 id="all-in-one-function">All in One Function</h3>
<p>The pure function portion of the exercise will read as the following:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">report</span> <span class="n">file</span> <span class="o">=</span> 
	<span class="kr">let</span>
		<span class="n">parsed</span>		<span class="o">=</span> <span class="n">map</span> <span class="n">words</span> <span class="o">.</span> <span class="n">lines</span> <span class="o">$</span> <span class="n">file</span>
		<span class="n">students</span>	<span class="o">=</span> <span class="n">map</span> <span class="n">name</span> <span class="n">parsed</span>
		<span class="n">averages</span>	<span class="o">=</span> <span class="n">map</span> <span class="n">average</span> <span class="n">parsed</span>
		<span class="n">zipped</span>		<span class="o">=</span> <span class="n">zipWith</span> <span class="n">report_line</span> <span class="n">students</span> <span class="n">averages</span>
	<span class="kr">in</span>
		<span class="n">unlines</span> <span class="n">zipped</span>
</code></pre></div></div>

<h1 id="comp105---lecture-17-2"><a href="/UoL/comp105/lectures/2020/11/17/2.html">COMP105 - Lecture 17-2</a></h1>
<h2 id="more-higher-order-functions---continued">More Higher Order Functions - Continued</h2>
<h3 id="takewhile"><code class="language-plaintext highlighter-rouge">takewhile</code></h3>
<p>This function takes while a condition is true.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;=</span><span class="mi">5</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div></div>

<p>This is different to <code class="language-plaintext highlighter-rouge">filter</code> which only removes individual elements.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">length</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="s">"ab"</span><span class="p">,</span><span class="s">"cd"</span><span class="p">,</span><span class="s">"efg"</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="s">"ab"</span><span class="p">,</span> <span class="s">"cd"</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="implementation">Implementation</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">takeWhile'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="n">takeWhile'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">takeWhile'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">takeWhile'</span> <span class="n">f</span> <span class="n">xs</span>
	<span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="kt">[]</span>
</code></pre></div></div>

<h3 id="dropwhile"><code class="language-plaintext highlighter-rouge">dropWhile</code></h3>
<p>This is the opposite of the previous function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>You can also use functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="implementation-1">Implementation</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dropWhile'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">A</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

<span class="n">dropWhile'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">dropWhile'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">dropWhile'</span> <span class="n">f</span> <span class="n">xs</span>
	<span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span><span class="n">xs</span>
</code></pre></div></div>

<h3 id="takewhile--dropwhile-example"><code class="language-plaintext highlighter-rouge">takeWhile</code> &amp; <code class="language-plaintext highlighter-rouge">dropWhile</code> Example</h3>
<p>This function splits up the words in a string into a list of strings containing no spaces.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">split_words</span> <span class="s">""</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">split_words</span> <span class="n">string</span> <span class="o">=</span>
	<span class="kr">let</span>
		<span class="n">first</span> <span class="o">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">/=</span> <span class="sc">' '</span><span class="p">)</span> <span class="n">string</span>
		<span class="n">up_to_space</span> <span class="o">=</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">\=</span> <span class="sc">' '</span><span class="p">)</span> <span class="n">string</span>
		<span class="n">after_space</span> <span class="o">=</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">==</span> <span class="sc">' '</span><span class="p">)</span> <span class="n">up_to_space</span>
	<span class="kr">in</span>
		<span class="n">first</span> <span class="o">:</span> <span class="n">split_words</span> <span class="n">after_space</span>

<span class="o">&gt;</span> <span class="n">split_words</span> <span class="s">"one two		three"</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="s">"one"</span><span class="p">,</span><span class="s">"two"</span><span class="p">,</span><span class="s">"three"</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="words"><code class="language-plaintext highlighter-rouge">words</code></h3>
<p>The function that was made in the last example has a standard implementation called <code class="language-plaintext highlighter-rouge">words</code>.</p>

<h3 id="unwords"><code class="language-plaintext highlighter-rouge">unwords</code></h3>
<p>This is the companion function to <code class="language-plaintext highlighter-rouge">words</code>. They arenâ€™t quite inverses as <code class="language-plaintext highlighter-rouge">unwords</code> will put spaces inbetween each word.</p>

<h3 id="zipwith"><code class="language-plaintext highlighter-rouge">zipWith</code></h3>
<p>This function zips two lists together using a function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">y</span> <span class="kr">else</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">,</span> <span class="kt">True</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="implementation-2">Implementation</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">zipWith'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>

<span class="n">zipWith'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zipWith'</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zipWith'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">zipWith'</span> <span class="n">f</span> <span class="n">xs</span> <span class="n">ys</span>
</code></pre></div></div>

<h4 id="examples">Examples</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mult_by_pos</span> <span class="n">list</span> <span class="o">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">list</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span>

<span class="o">&gt;</span> <span class="n">mult_by_pos</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">interleave</span> <span class="n">str1</span> <span class="n">str2</span> <span class="o">=</span> 
	<span class="kr">let</span>
		<span class="n">zipped</span> <span class="o">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">])</span> <span class="n">str1</span> <span class="n">str2</span>
	<span class="kr">in</span>
		<span class="n">concat</span> <span class="n">zipped</span>

<span class="o">&gt;</span> <span class="n">interleave</span> <span class="s">"abc"</span> <span class="s">"123"</span>
<span class="o">&gt;</span> <span class="s">"a1b2c3"</span>
</code></pre></div></div>

<p>In this example <code class="language-plaintext highlighter-rouge">concat</code> is used to make lists of strings into a single string.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">getNumber</span> <span class="n">string</span> <span class="o">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">elem</span> <span class="n">x</span> <span class="p">[</span><span class="sc">'0'</span><span class="o">..</span><span class="sc">'9'</span><span class="p">])</span> <span class="n">string</span>
</code></pre></div>    </div>
  </li>
  <li>
    <pre><code class="language-hasell"> wordCount string = length $ words string
</code></pre>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">numberWords</span> <span class="n">string</span> <span class="o">=</span> <span class="n">zip</span> <span class="o">$</span> <span class="n">words</span> <span class="n">string</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-17-1"><a href="/UoL/comp105/lectures/2020/11/17/1.html">COMP105 - Lecture 17-1</a></h1>
<h2 id="more-higher-order-functions">More Higher Order Functions</h2>
<h3 id="scan">Scan</h3>
<p>The scan set of functions is similar to the fold set of functions. However instead of outputting a single value it outputs a list showing the accumulator at each step in the function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">scanr</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">scanr</code> is implemented like so:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scanr'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>

<span class="n">scanr'</span> <span class="kr">_</span> <span class="n">init</span> <span class="kt">[]</span> <span class="o">=</span> <span class="p">[</span><span class="n">init</span><span class="p">]</span>
<span class="n">scanr'</span> <span class="n">f</span> <span class="n">init</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span>
	<span class="kr">let</span>
		<span class="n">recursed</span> <span class="o">=</span> <span class="n">scanr'</span> <span class="n">f</span> <span class="n">init</span> <span class="n">xs</span>
		<span class="n">new</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">head</span> <span class="n">recursed</span><span class="p">)</span>
	<span class="kr">in</span>
		<span class="n">new</span> <span class="o">:</span> <span class="n">recursed</span>
</code></pre></div></div>

<h4 id="scan-variants">Scan Variants</h4>
<p>There are also left to right versions of scan:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">scanl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">55</span><span class="p">]</span>
</code></pre></div></div>

<p>A good way to understand the accumulator in a fold is to do a scan and observe the output.</p>

<h4 id="fibonacci-example">Fibonacci Example</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fib_pairs</span> <span class="n">n</span> <span class="o">=</span> <span class="n">scanl</span> <span class="p">(</span><span class="nf">\</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="kr">_</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">))</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
<span class="n">fib_to_n</span> <span class="n">n</span> <span class="o">=</span> <span class="n">map</span> <span class="n">fst</span> <span class="p">(</span><span class="n">fib_pairs</span> <span class="n">n</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">fib_pairs</span> <span class="mi">3</span>
<span class="o">&gt;</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>

<span class="o">&gt;</span> <span class="n">fib_to_n</span> <span class="mi">3</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">prefixMaximum</span> <span class="n">list</span> <span class="o">=</span> <span class="n">scanl1</span> <span class="n">max</span> <span class="n">list</span>
</code></pre></div>    </div>

    <p>As <code class="language-plaintext highlighter-rouge">max</code> is already a two argument function that takes <code class="language-plaintext highlighter-rouge">acc</code> and <code class="language-plaintext highlighter-rouge">x</code>, then we donâ€™t have to make our own anonymous function.</p>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">powersOfTwo</span> <span class="n">n</span> <span class="o">=</span> <span class="n">scanl</span> <span class="p">(</span><span class="nf">\</span> <span class="n">acc</span> <span class="kr">_</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">acc</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-16-2"><a href="/UoL/comp105/lectures/2020/11/16/2.html">COMP105 - Lecture 16-2</a></h1>
<h2 id="fold-continued">Fold Continued</h2>
<p>A fold output can be a different type to the input list.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">to_csv</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">","</span> <span class="o">++</span> <span class="n">acc</span><span class="p">)</span>  <span class="s">""</span> <span class="n">list</span>

<span class="o">&gt;</span> <span class="n">to_csv</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="s">"1,2,3,4,"</span>
</code></pre></div></div>

<p>By using <code class="language-plaintext highlighter-rouge">foldr</code> you cannot get the desired outcome as it applies the same rule to every item in the list.</p>

<h3 id="foldr1"><code class="language-plaintext highlighter-rouge">foldr1</code></h3>
<p>The function <code class="language-plaintext highlighter-rouge">foldr1</code> uses the final value of the list to initialise the accumulator:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldr1</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>

<span class="n">foldr1'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">error</span> <span class="s">"empty list"</span>
<span class="n">foldr1'</span> <span class="o">-</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
<span class="n">foldr1'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">foldr1'</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">foldr1'</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">15</span>
</code></pre></div></div>

<p>As the accumulator has the same type as the list elements <code class="language-plaintext highlighter-rouge">foldr1</code> cannot have a different type to that of the elements in the list.</p>

<h4 id="example">Example</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">maximum'</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">acc</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="n">list</span>

<span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">4</span>
</code></pre></div></div>

<p>In this example <code class="language-plaintext highlighter-rouge">foldr1</code> is required as your initialisation may become the maximum value.</p>

<h3 id="foldl"><code class="language-plaintext highlighter-rouge">foldl</code></h3>
<p><code class="language-plaintext highlighter-rouge">foldr</code> processes lists from the right. The opposite of this is <code class="language-plaintext highlighter-rouge">foldl</code> which processes lists from the left. For many functions like <code class="language-plaintext highlighter-rouge">+</code> the ordering doesnâ€™t matter but for other functions such as <code class="language-plaintext highlighter-rouge">/</code>.</p>

<h4 id="type-of-foldl">Type of <code class="language-plaintext highlighter-rouge">foldl</code></h4>
<p>The function <code class="language-plaintext highlighter-rouge">f</code> has its type flipped compared to the other <code class="language-plaintext highlighter-rouge">fold</code> function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldr</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">foldl</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">b</span>
</code></pre></div></div>

<p>This also means that you should swap your functions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">foldr (\ x acc -&gt; ...</code></li>
  <li><code class="language-plaintext highlighter-rouge">foldr (\ acc x -&gt; ...</code></li>
</ul>

<h5 id="example-1">Example</h5>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reverse_list</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span> <span class="n">acc</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">list</span>

<span class="o">&gt;</span> <span class="n">reverse_list</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">sumFsts list = foldr (\ (x,_) acc -&gt; x + acc) 0 list</code></li>
  <li><code class="language-plaintext highlighter-rouge">minimum list = foldr1 (\ x acc -&gt; if x &lt; acc then x else acc) list</code></li>
  <li><code class="language-plaintext highlighter-rouge">dash string = foldl (\ acc x -&gt; acc ++ [x, '-']) "" string</code></li>
</ol>

<h1 id="comp105---lecture-16-1"><a href="/UoL/comp105/lectures/2020/11/16/1.html">COMP105 - Lecture 16-1</a></h1>
<h2 id="fold">Fold</h2>
<p>Some functions take lists and turn them into a single value. This type of computation is called a fold. The things that you can change are:</p>

<ul>
  <li>The base case.</li>
  <li>The operation applied to the list.</li>
</ul>

<h3 id="foldr"><code class="language-plaintext highlighter-rouge">foldr</code></h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldr'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">b</span>

<span class="n">foldr'</span> <span class="kr">_</span> <span class="n">init</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">init</span>
<span class="n">foldr'</span> <span class="n">f</span> <span class="n">init</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">foldr'</span> <span class="n">f</span> <span class="n">init</span> <span class="n">xs</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">foldr'</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">55</span>

<span class="o">&gt;</span> <span class="n">foldr'</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">3628800</span>
</code></pre></div></div>

<h4 id="the-folded-function">The Folded Function</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sum''</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="n">list</span>
</code></pre></div></div>

<p>The folded function <code class="language-plaintext highlighter-rouge">f</code> takes two arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">x</code> is an element form the list.</li>
  <li><code class="language-plaintext highlighter-rouge">acc</code> is the accumulator.</li>
</ul>

<p>The function outputs a new value for the accumulator:</p>

<ul>
  <li>The initial value for the accumulator is <code class="language-plaintext highlighter-rouge">init</code>.</li>
  <li>The final value for the accumulator is the output of <code class="language-plaintext highlighter-rouge">foldr</code>.</li>
</ul>

<h5 id="example">Example</h5>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>Values for the accumulator:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>init	= 0
0 + 4	= 4
4 + 3	= 7
7 + 2	= 9
9 + 1	= 10
</code></pre></div></div>

<p>Final output: <code class="language-plaintext highlighter-rouge">10</code></p>

<h4 id="an-imperative-equivalent">An Imperative Equivalent:</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">foldr</span> <span class="n">f</span> <span class="n">init</span> <span class="n">input_list</span>
</code></pre></div></div>

<p>In python this would be implemented as:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">acc</span> <span class="o">=</span> <span class="n">init</span>
<span class="n">input_list</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_list</span><span class="p">)):</span>
	<span class="n">acc</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">input_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">acc</span><span class="p">)</span>

<span class="k">return</span> <span class="n">acc</span>
</code></pre></div></div>

<h4 id="foldr-examples"><code class="language-plaintext highlighter-rouge">foldr</code> Examples</h4>

<p>Whenever you fold a binary operator you are putting that operator in-between each element on the list. If you are using <code class="language-plaintext highlighter-rouge">foldr</code> then you will put the initial value on the right hand side.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">concat'</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">list</span>

<span class="o">&gt;</span> <span class="n">concat'</span> <span class="p">[</span><span class="s">"Hello "</span><span class="p">,</span> <span class="s">"there."</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="s">"Hello there."</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">all'</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="kt">True</span> <span class="n">list</span>

<span class="o">&gt;</span> <span class="n">all'</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="kt">True</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length'</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span> <span class="kr">_</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="n">list</span>

<span class="o">&gt;</span> <span class="n">length'</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">4</span>
</code></pre></div></div>

<p>This example shows that you just need to apply a function to the accumulator for each element in the list. It doesnâ€™t need to be specifically including items in the list:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">count_ones</span> <span class="n">list</span> <span class="o">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="n">acc</span> <span class="o">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span> <span class="kr">then</span> <span class="n">acc</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="mi">0</span> <span class="n">list</span>

<span class="o">&gt;</span> <span class="n">count_ones</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="mi">3</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">any' list = foldr (||) False list</code></li>
  <li><code class="language-plaintext highlighter-rouge">countEs string = foldr (\ x acc -&gt; if x == 'e' then acc + 1 else acc) 0  string</code></li>
  <li><code class="language-plaintext highlighter-rouge">sumOfEvens list  = foldr (\ x acc -&gt; if even x then acc + x else acc) 0 list</code></li>
</ol>

<h1 id="comp105---lecture-15-2"><a href="/UoL/comp105/lectures/2020/11/12/2.html">COMP105 - Lecture 15-2</a></h1>
<h2 id="filter"><code class="language-plaintext highlighter-rouge">filter</code></h2>
<p><code class="language-plaintext highlighter-rouge">filter</code>keeps only the elements for which <code class="language-plaintext highlighter-rouge">f</code> returns <code class="language-plaintext highlighter-rouge">True</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filter'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">filter'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">filter'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">f</span> <span class="n">x</span> 		<span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">rest</span>
	<span class="o">|</span> <span class="n">otherwise</span>	<span class="o">=</span> <span class="n">rest</span>
	<span class="kr">where</span> <span class="n">rest</span> 	<span class="o">=</span> <span class="n">filter'</span> <span class="n">f</span> <span class="n">xs</span>
	
<span class="n">filter'</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div></div>

<p>In comparison to <code class="language-plaintext highlighter-rouge">map</code> which applies a function to each element in a list. <code class="language-plaintext highlighter-rouge">filter</code> will apply a boolean test to each element in the list and if it fails it will remove the element from the list.</p>

<h3 id="combining-map--filter">Combining <code class="language-plaintext highlighter-rouge">map</code> &amp; <code class="language-plaintext highlighter-rouge">filter</code></h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">square_even</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="n">square_even</span> <span class="n">list</span> <span class="o">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="n">filter</span> <span class="n">even</span> <span class="n">list</span><span class="p">)</span>

<span class="n">square_even</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="higher-order-programming">Higher Order Programming</h2>
<p><code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code> are examples of higher order programming. This style:</p>

<ul>
  <li>De-emphasises recursion.</li>
  <li>Focuses on applying functions to lists.</li>
  <li>Are available in imperative languages (Python C++).</li>
</ul>

<p>There is a whole family of higher order programming functions available in Haskell.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">onlyDiv3 = filter (\x -&gt; mod x 3 == 0)</code></li>
  <li><code class="language-plaintext highlighter-rouge">onlyLower = filter (\x -&gt; elem x ['a'..'z'])</code></li>
  <li><code class="language-plaintext highlighter-rouge">noEven = map (filter odd)</code></li>
</ol>

<h1 id="comp105---lecture-15-1"><a href="/UoL/comp105/lectures/2020/11/12/1.html">COMP105 - Lecture 15-1</a></h1>
<h2 id="map"><code class="language-plaintext highlighter-rouge">map</code></h2>
<p><code class="language-plaintext highlighter-rouge">map</code> applies a funciton <code class="language-plaintext highlighter-rouge">f</code> to every element in a list.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map'</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">map'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">map'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:</span> <span class="n">map'</span> <span class="n">f</span> <span class="n">xs</span>
</code></pre></div></div>

<p>This saves you from writing out the generic code for applying a function to a list. This allows you to implement the standard functions instead of having to make your own.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="kt">False</span><span class="p">,</span><span class="kt">True</span><span class="p">,</span><span class="kt">False</span><span class="p">,</span><span class="kt">True</span><span class="p">,</span><span class="kt">False</span><span class="p">]</span>
</code></pre></div></div>

<p>This avoids writing a recursive function for applying simple list operations.</p>

<h3 id="currying-and-map">Currying and <code class="language-plaintext highlighter-rouge">map</code></h3>
<p>It is common to use curried functions with <code class="language-plaintext highlighter-rouge">map</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div></div>

<p>You can also use map to make other functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">doubleList</span> <span class="o">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">doubleList</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="anonymous-functions-and-map">Anonymous Functions and Map</h3>
<p>It is also common to use an anonymous functions with map:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
</code></pre></div></div>

<p>This lets you apply your own functions to a list without having to define it.</p>

<h3 id="nested-maps">Nested Maps</h3>
<p>When working with nested lists, it is common to use nested maps.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">],[</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">]]</span>

<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="n">map</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="p">[</span><span class="s">"the"</span><span class="p">,</span><span class="s">"quick"</span><span class="p">,</span><span class="s">"brown"</span><span class="p">]</span>
<span class="p">[</span><span class="s">"THE"</span><span class="p">,</span><span class="s">"QUICK"</span><span class="p">,</span><span class="s">"BROWN"</span><span class="p">]</span>
</code></pre></div></div>

<p>This application uses currying in the inner map. It is also especially useful for lists containing strings.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">cubeList = map (^3)</code></li>
  <li><code class="language-plaintext highlighter-rouge">middleElem = map (\(_,x,_) -&gt; x)</code></li>
  <li><code class="language-plaintext highlighter-rouge">ruinStrings = map (map (\x -&gt; if x == 'e' then 'x' else x))</code></li>
</ol>

<h1 id="comp105---lecture-14-3"><a href="/UoL/comp105/lectures/2020/11/10/3.html">COMP105 - Lecture 14-3</a></h1>
<h2 id="anonymous-functions">Anonymous Functions</h2>
<p>Sometimes is it convenient to define a function inline. Anonymous functions allow you to use a function without a name.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">7</span>
<span class="o">&gt;</span> <span class="mi">8</span>
</code></pre></div></div>

<p>This allows you to pass functions to a higher order function without giving it a name:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">apply_twice</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="p">)</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="mi">8</span>
</code></pre></div></div>

<h3 id="syntax">Syntax</h3>
<p>The syntax for an anonymous function is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">\</span> <span class="p">[</span><span class="n">arg1</span><span class="p">]</span> <span class="p">[</span><span class="n">arg2</span><span class="p">]</span>  <span class="o">...</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">expression</span><span class="p">]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">\</code> is supposed to resemble an lambda $\lambda$.</p>

<ul>
  <li>Anonymous function are sometimes called $\lambda$-functions in recognition of lambda calculus.</li>
</ul>

<h3 id="functions-that-return-functions">Functions that Return Functions</h3>
<p>Higher order functions can also return other functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f_than_adds_n</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span>
<span class="n">f_that_adds_n</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="kr">let</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_that_adds_n</span> <span class="mi">10</span><span class="p">)</span> <span class="kr">in</span> <span class="p">(</span><span class="n">f</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mi">11</span>
</code></pre></div></div>

<p>This function returns another function that you can use in other functions.</p>

<p>Higher order function can take and return functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">swap</span> <span class="n">f</span> <span class="o">=</span> <span class="nf">\</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</code></pre></div></div>

<p>This is a two argument function and then swaps the arguments for the function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">g</span> <span class="o">=</span> <span class="n">swap</span> <span class="n">take</span>
</code></pre></div></div>

<p>This has swapped the arguments for the function <code class="language-plaintext highlighter-rouge">take</code> and can be called with <code class="language-plaintext highlighter-rouge">g</code></p>

<h3 id="currying-revisited">Currying Revisited</h3>
<p>Previously weâ€™ve seen that it is possible to partially apply a function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add_two</span> <span class="o">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>This is just a nicer syntax for a function that returns a function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add_two</span> <span class="o">=</span> <span class="p">(</span><span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> (\ x y -&gt; x + y)
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> addChar c = (\ string -&gt; string ++ [c])
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> curry' :: ((a, b) -&gt; c) -&gt; (a -&gt; b -&gt; c)
 curry' f = (\ x y -&gt; f (x, y))
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-14-2"><a href="/UoL/comp105/lectures/2020/11/10/2.html">COMP105 - Lecture 14-2</a></h1>
<h2 id="higher-order-functions">Higher Order Functions</h2>
<p>A higher order function is a function that:</p>

<ul>
  <li>Takes another function as an argument.</li>
  <li>Returns a function.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">apply_twice</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">apply_twice</span> <span class="n">f</span> <span class="n">input</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">input</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">apply_twice</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</code></pre></div></div>

<p>This function takes a function and an input as an argument and then uses the supplied function twice on the supplied argument.</p>

<p>An example including currying (partial application):</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">apply_twice</span> <span class="p">(</span><span class="n">drop</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</code></pre></div></div>

<p>A caveat of using this function is that it must return the same type that is is given.</p>

<h3 id="function-composition">Function Composition</h3>
<p>Function composition applies one function to the output of another</p>

<ul>
  <li>Composing <code class="language-plaintext highlighter-rouge">f</code> with <code class="language-plaintext highlighter-rouge">g input</code> gives <code class="language-plaintext highlighter-rouge">f (g input)</code></li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">compose</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">compose</span> <span class="n">f</span> <span class="n">g</span> <span class="n">input</span> <span class="o">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">input</span><span class="p">)</span>

<span class="o">&gt;</span> <span class="n">compose</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">4</span>
<span class="o">&gt;</span> <span class="mi">9</span>
</code></pre></div></div>

<p>This is the same thing as applying a function to another function.</p>

<h4 id="the--operator">The <code class="language-plaintext highlighter-rouge">.</code> Operator</h4>
<p>The type of <code class="language-plaintext highlighter-rouge">.</code> is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="n">b</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">c</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">.</code> operator is an infix operator called compose. To complete the same action as will the <code class="language-plaintext highlighter-rouge">compose</code> function write:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">((</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="mi">4</span>
<span class="o">&gt;</span> <span class="mi">9</span>
</code></pre></div></div>

<p>This means to apply the left function on the argument and then the right function on the result of the previous function.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">list</span> <span class="o">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">double</span> <span class="p">(</span><span class="n">drop_evens</span> <span class="p">(</span><span class="n">tail</span> <span class="n">list</span><span class="p">)))</span>

<span class="n">f'</span> <span class="n">list</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">.</span> <span class="n">double</span> <span class="o">.</span> <span class="n">drop</span> <span class="n">evens</span> <span class="o">.</span> <span class="n">tail</span><span class="p">)</span> <span class="n">list</span>
</code></pre></div></div>

<p>As you can see from the two different implementations; the use of <code class="language-plaintext highlighter-rouge">.</code> removes the need for nested brackets, however:</p>

<ul>
  <li>It is stylistic.</li>
  <li>You never need to use <code class="language-plaintext highlighter-rouge">.</code></li>
  <li>It is preferred.</li>
</ul>

<h3 id="the--operator-1">The <code class="language-plaintext highlighter-rouge">$</code> Operator</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">evaluate</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">evaluate</span> <span class="n">f</span> <span class="n">input</span> <span class="o">=</span> <span class="n">f</span> <span class="n">input</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">$</code> operator is exactly the same as evaluate. <code class="language-plaintext highlighter-rouge">$</code> is infix.</p>

<p>The <code class="language-plaintext highlighter-rouge">$</code> operator has the lowest precedence of any operator. As a result it can be used in place of brackets:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">.</span> <span class="n">length</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">.</span> <span class="n">length</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>

<span class="n">length</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
<span class="n">length</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> applyThrice :: (a -&gt; a) -&gt; a -&gt; a
 applyThrice f x = f . f . f $ x
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> f :: (Ord a, Enum a) =&gt; [a] -&gt; a
 f x = succ . sum . tail . tail $ x
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-14-1"><a href="/UoL/comp105/lectures/2020/11/10/1.html">COMP105 - Lecture 14-1</a></h1>
<h2 id="more-type-classes">More Type Classes</h2>
<h3 id="show"><code class="language-plaintext highlighter-rouge">show</code></h3>
<p>This function converts other types to strings. However, it can only take the type class of <code class="language-plaintext highlighter-rouge">Show</code> into a string:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">show</span> <span class="o">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Show</code> contains:</p>

<ul>
  <li>All basic types.</li>
  <li>All tuples of show-able types.</li>
  <li>All lists of show-able types.</li>
</ul>

<h3 id="read"><code class="language-plaintext highlighter-rouge">read</code></h3>
<p>This converts strings to other types, provided they are formatted correctly:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span> <span class="s">"123"</span> <span class="o">::</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>In this case the use of <code class="language-plaintext highlighter-rouge">::</code> is necessary to tell Haskell what type the function should return.</p>

<p>In cases where type inference can be used, the <code class="language-plaintext highlighter-rouge">::</code> is not required:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">not</span> <span class="p">(</span><span class="n">read</span> <span class="s">"False"</span><span class="p">)</span>
</code></pre></div></div>

<p>The type of <code class="language-plaintext highlighter-rouge">read</code> is the type class <code class="language-plaintext highlighter-rouge">Read</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">read</span> <span class="o">::</span> <span class="kt">Read</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Read</code> contains:</p>

<ul>
  <li>All basic types.</li>
  <li>All tuples of readable types.</li>
  <li>All lists of readable types.</li>
</ul>

<h3 id="ordered-types">Ordered Types</h3>
<p>The type class to compare two objects by inequality is <code class="language-plaintext highlighter-rouge">Ord</code>. This is required for using functions such as <code class="language-plaintext highlighter-rouge">&gt;</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Ord</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p>All basic types can be compared including tuples and lists. Tuples and lists are compared <strong>lexicographically</strong> (similar to alphabetically ordering words).</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">showTuple :: (Show a, Show b) =&gt; (a, b) -&gt; [Char]</code></li>
  <li><code class="language-plaintext highlighter-rouge">addThree :: (Num a, Read a) =&gt; String -&gt; a</code></li>
  <li><code class="language-plaintext highlighter-rouge">headLt10 :: (Num a, Ord a) =&gt; [a] -&gt; Bool</code></li>
</ol>

<h1 id="comp105---lecture-13-2"><a href="/UoL/comp105/lectures/2020/11/09/2.html">COMP105 - Lecture 13-2</a></h1>
<h2 id="type-classes">Type Classes</h2>
<p>Some functions are polymorphic, but canâ€™t be applied to any type. <code class="language-plaintext highlighter-rouge">+</code> is a good example. It can work on <code class="language-plaintext highlighter-rouge">float</code> and <code class="language-plaintext highlighter-rouge">integer</code> but not on mixed types or <code class="language-plaintext highlighter-rouge">Char</code>. The type of <code class="language-plaintext highlighter-rouge">+</code> is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>This means that <code class="language-plaintext highlighter-rouge">a</code> is a number in the definition: <code class="language-plaintext highlighter-rouge">a -&gt; a -&gt; a</code>.</p>

<h3 id="num"><code class="language-plaintext highlighter-rouge">Num</code></h3>
<p><code class="language-plaintext highlighter-rouge">Num</code> is a type class:</p>

<ul>
  <li>It restricts the type variable <code class="language-plaintext highlighter-rouge">a</code> to only be number types.</li>
  <li><code class="language-plaintext highlighter-rouge">Word</code>, <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Integer</code>, <code class="language-plaintext highlighter-rouge">Float</code>, <code class="language-plaintext highlighter-rouge">Double</code> are all contained in <code class="language-plaintext highlighter-rouge">Num</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Char</code>, <code class="language-plaintext highlighter-rouge">Bool</code>, tuples and lists are not in <code class="language-plaintext highlighter-rouge">Num</code>.</li>
</ul>

<h4 id="num-sub-classes"><code class="language-plaintext highlighter-rouge">Num</code> Sub-Classes</h4>
<p><code class="language-plaintext highlighter-rouge">Num</code> has two sub-classes.</p>

<p><code class="language-plaintext highlighter-rouge">Integral</code> represents whole numbers and contains:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Word</code> (un-signed integers)</li>
  <li><code class="language-plaintext highlighter-rouge">Int</code></li>
  <li><code class="language-plaintext highlighter-rouge">Integer</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Fractional</code> represents rationals and contains:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Float</code></li>
  <li><code class="language-plaintext highlighter-rouge">Double</code></li>
  <li><code class="language-plaintext highlighter-rouge">Rational</code></li>
</ul>

<h3 id="eq"><code class="language-plaintext highlighter-rouge">Eq</code></h3>
<p>The types in the class <code class="language-plaintext highlighter-rouge">Eq</code> are the types which can be compared with the function <code class="language-plaintext highlighter-rouge">==</code>. There are no default types which arenâ€™t equality testable but if you make your own type then you will have to add it to this class.</p>

<h2 id="type-class-syntax">Type Class Syntax</h2>
<p>The syntax of a class type is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="kt">Type</span> <span class="kr">class</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="kt">Type</span> <span class="kr">class</span> <span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="kt">Type</span><span class="p">]</span>
</code></pre></div></div>

<p>This results in a declaration similar to the following:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">equals_two</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
<span class="n">equals_two</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">2</span>
</code></pre></div></div>

<p>This type declaration also means that if you use functions like <code class="language-plaintext highlighter-rouge">==</code> in your function then you must specify that the type is comparable with <code class="language-plaintext highlighter-rouge">Eq a</code>. If you donâ€™t then the compiler will give an error.</p>

<h2 id="the-most-general-type-annotation">The Most General Type Annotation</h2>
<p>The most general type annotation is the one that is least restrictive. Ideally you want your type annotation to be the most general without giving an error:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">equals_two</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">2</span>

<span class="c1">-- Too restrictive</span>
<span class="n">equals_two</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

<span class="c1">-- Most general</span>
<span class="n">equals_two</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>

<span class="c1">-- Too general (will give error)</span>
<span class="n">equals_two</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<p class="info">The most general type annotation is the one which allows the most valid types</p>

<h2 id="numbers">Numbers</h2>
<p>In Haskell numbers, such as <code class="language-plaintext highlighter-rouge">10</code> have a <strong>polymorphic type</strong>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">10</span> <span class="o">::</span> <span class="kt">Num</span> <span class="n">p</span> <span class="o">=&gt;</span> <span class="n">p</span>
</code></pre></div></div>

<p>This means that, unless stated explicitly that numbers will be converted to the most suitable type in the class of <code class="language-plaintext highlighter-rouge">Num</code>.</p>

<p>You can force a number to be a particular type by using the <code class="language-plaintext highlighter-rouge">::</code> operator:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">::</span> <span class="kt">Integer</span>
<span class="o">&gt;</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="o">::</span> <span class="kt">Float</span>
<span class="o">&gt;</span> <span class="mf">1.0</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">fromIntegral</code> will take any <code class="language-plaintext highlighter-rouge">Integral</code> type and convert it into a <code class="language-plaintext highlighter-rouge">Num</code> type. This, for example would allow you to use the <code class="language-plaintext highlighter-rouge">/</code> operator on an <code class="language-plaintext highlighter-rouge">Integer</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fromIntegral</span> <span class="p">(</span><span class="mi">1</span> <span class="o">::</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="mf">0.5</span>
</code></pre></div></div>
<h3 id="converting-floats-to-integers">Converting Floats to Integers</h3>
<p>Converting floats to integers is a lossy operation. This means that you shoul choose how to complete the rounding:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ceiling</span> <span class="mf">1.6</span>
<span class="o">&gt;</span> <span class="mi">2</span>

<span class="n">floor</span> <span class="mf">1.6</span>
<span class="o">&gt;</span> <span class="mi">1</span>

<span class="n">truncate</span> <span class="mf">1.6</span>
<span class="o">&gt;</span> <span class="mi">1</span>

<span class="n">round</span> <span class="mf">1.6</span>
<span class="o">&gt;</span> <span class="mi">2</span>
</code></pre></div></div>

<h2 id="other-type-classes">Other Type Classes</h2>
<p>There are many other type classes in Haskell that wonâ€™t be covered:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span> <span class="o">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="o">=&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>This that <code class="language-plaintext highlighter-rouge">a</code> should be accepted if it is a list.</p>

<p>If you see any of the following as a types:</p>

<ul>
  <li>Functor</li>
  <li>Foldable</li>
  <li>Traversable</li>
</ul>

<p>then think <strong>list</strong>.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">square_area :: Num a =&gt; a -&gt; a -&gt; a</code></li>
  <li><code class="language-plaintext highlighter-rouge">triangle_area :: Fractional a  =&gt; a -&gt; a -&gt; a</code></li>
  <li><code class="language-plaintext highlighter-rouge">equal_heads :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code></li>
</ol>

<h1 id="comp105---lecture-13-1"><a href="/UoL/comp105/lectures/2020/11/09/1.html">COMP105 - Lecture 13-1</a></h1>
<h2 id="polymorphic-types">Polymorphic Types</h2>
<p>Some functions accept many different types. An example of this is <code class="language-plaintext highlighter-rouge">length</code> which accepts many different types of lists.</p>

<p>if you ask what the type of then function <code class="language-plaintext highlighter-rouge">length</code> is then it will return the type:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">a</code> is a type variable. This means that:</p>

<ul>
  <li>The function can be applied to any list.</li>
  <li><code class="language-plaintext highlighter-rouge">a</code> will represent the type of list elements.</li>
</ul>

<p>This type is called <strong>polymorphism</strong>. This is a feature of functional languages.</p>

<h2 id="type-variables">Type Variables</h2>
<p>In the function <code class="language-plaintext highlighter-rouge">head</code> it will return the type variable which it was given in the list. Hence asking for the type returns:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">head</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>Type variables can appear more than once. These types specify that the return type will be determined by the type of the input.</p>

<p>Multiple type variables can be included in one declaration for example the function <code class="language-plaintext highlighter-rouge">fst</code> returns the following:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fst</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<p>As a result the types of function can tell you a lot about what the function does.</p>

<h2 id="type-annotations">Type Annotations</h2>
<p>Is it good practice to insert type annotations for your functions. This is so that Haskell assigns the types to your functions that you expect. You do this with the following syntax.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The annotation is usually place before the function definition. If you donâ€™t give a type annotation, then Haskell will <em>infer</em> one for you based on the functions used in your function. This is a result of the language being strongly typed.</p>

<p>Annotating your function can make it easier to catch bugs. This will give the compiler more to work with and make errors more descriptive.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">take :: Int -&gt; [a] -&gt; [a]</code></li>
  <li><code class="language-plaintext highlighter-rouge">(:) :: a -&gt; [a] -&gt; [a]</code></li>
  <li><code class="language-plaintext highlighter-rouge">(++) :: [a] -&gt; [a] -&gt; [a]</code></li>
</ol>

<h1 id="comp105---lecture-12-2"><a href="/UoL/comp105/lectures/2020/11/06/2.html">COMP105 - Lecture 12-2</a></h1>
<h2 id="function-types">Function Types</h2>
<p>Functions also have types in the type system. The type of a function is based on the values it takes as an argument and returns.</p>

<h3 id="single-argument-functions">Single Argument Functions</h3>
<p>For a one argument function, the type is written as:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">input</span> <span class="kr">type</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">output</span> <span class="kr">type</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="multi-argument-functions">Multi-Argument Functions</h3>
<p>For a function with more than one argument, the type uses multiple <code class="language-plaintext highlighter-rouge">-&gt;</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">input</span> <span class="kr">type</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">input</span> <span class="kr">type</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">output</span> <span class="kr">type</span><span class="p">]</span>
</code></pre></div></div>

<p>This makes sense as a Haskell function can only return a single type.</p>

<h3 id="partial-application">Partial Application</h3>
<p>In most functional languages, function can be <strong>partially applied</strong>. This means that you call a function with fewer arguments than are required.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plus</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

<span class="n">plus2</span> <span class="o">=</span> <span class="n">plus</span> <span class="mi">2</span>

<span class="o">&gt;</span> <span class="n">plus2</span> <span class="mi">10</span>
<span class="o">&gt;</span> <span class="mi">12</span>

<span class="o">&gt;</span> <span class="n">plus2</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="mi">3</span>
</code></pre></div></div>

<p>As you can see <strong>currying</strong> a function is the same as applying a permanent input to a function and leaving the other one open. This means that:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="n">plus</span> <span class="mi">1</span>
</code></pre></div></div>

<p>is the same as:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="n">plus</span> <span class="mi">1</span> <span class="n">x</span>
</code></pre></div></div>

<p>In partial application:</p>

<ul>
  <li>We fix some of the arguments.</li>
  <li>We leave other arguments unfixed.</li>
</ul>

<p>This creates a new function that only has the unfixed arguments.</p>

<h4 id="partial-application-types">Partial Application Types</h4>
<p>As the function made in a partial application just a function that takes the unfixed arguments, the inputs are the types of the unfixed arguments. For the functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>

<span class="n">func2</span> <span class="o">=</span> <span class="n">func</span> <span class="mi">23</span>
</code></pre></div></div>

<p>The type would be <code class="language-plaintext highlighter-rouge">func2 :: Int -&gt; Int -&gt; Int</code>, as the unused arguments are carried over.</p>

<h4 id="argument-order">Argument Order</h4>
<p>The order of the partial application must follow the same order as the original function. This means that is makes more sense to use it on prefix functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="o">:</span><span class="p">)</span> <span class="mi">1</span>
</code></pre></div></div>

<p>This would allow you to cons <code class="language-plaintext highlighter-rouge">1</code> onto another list.</p>

<h4 id="partially-applying-infix-operators">Partially Applying Infix Operators</h4>
<p>To partially apply an infix operator see the following example:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>This will take a single input and divide it by two. As you can see the infix operator should be put in brackets.</p>

<h3 id="bracketing-for-function-types">Bracketing for Function Types</h3>
<p>Function application should be thought of multiple partial applications.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="n">multThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span>
</code></pre></div></div>

<p>This means that the function type brackets to the right:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
</code></pre></div></div>

<p>is the same as:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">))</span>
</code></pre></div></div>

<p>This is a first look at a <em>higher order function</em>. This means that we are writing one argument functions that return other functions.</p>

<h3 id="multiple-arguments-vs-tuples">Multiple Arguments v.s. Tuples</h3>
<p>Previously weâ€™ve seen that you can write function in two ways:</p>

<ul>
  <li>Using usual â€œspacesâ€ syntax.</li>
  <li>Using tuples.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">multThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
<span class="n">multThree'</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
</code></pre></div></div>

<p>These both do the same thing, but the second version cannot be partially applied. This means is is best to avoid tuples unless they are necessary.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">isA :: Char -&gt; Bool</code></li>
  <li><code class="language-plaintext highlighter-rouge">isADouble :: Char -&gt; Char -&gt; (Bool, Bool)</code></li>
  <li><code class="language-plaintext highlighter-rouge">exclaim :: [Char] -&gt; [Char]</code></li>
</ol>

<h1 id="comp105---lecture-12-1"><a href="/UoL/comp105/lectures/2020/11/06/1.html">COMP105 - Lecture 12-1</a></h1>
<h2 id="types">Types</h2>
<p>Everything in Haskell has a type. In GHCI <code class="language-plaintext highlighter-rouge">:type</code> or <code class="language-plaintext highlighter-rouge">:t</code> will display the type of an expression.</p>

<h3 id="basic-types">Basic Types</h3>
<h4 id="int"><code class="language-plaintext highlighter-rouge">Int</code></h4>
<p>Holds a 64-bit integer between $-2^{63}$ and $2^{63}-1$</p>

<h4 id="integer"><code class="language-plaintext highlighter-rouge">Integer</code></h4>
<p>Holds arbitrary size integers but is slightly slower than an <code class="language-plaintext highlighter-rouge">Int</code>. Ideally you should use an <code class="language-plaintext highlighter-rouge">Int</code> if you are using smaller numbers.</p>

<h4 id="float"><code class="language-plaintext highlighter-rouge">Float</code></h4>
<p>Holds 32-bit floating point numbers.</p>

<h4 id="double"><code class="language-plaintext highlighter-rouge">Double</code></h4>
<p>Holds a 64-bit floating point number.</p>

<h4 id="bool"><code class="language-plaintext highlighter-rouge">Bool</code></h4>
<p>Holds truth values.</p>

<h4 id="char"><code class="language-plaintext highlighter-rouge">Char</code></h4>
<p>Holds a single character and can store any Unicode character.</p>

<h3 id="compound-types">Compound Types</h3>
<h4 id="tuples">Tuples</h4>
<p>The type of a tuple is the type of its constituents.</p>

<ul>
  <li>The size of a tuple is encoded in its type.</li>
  <li>Tuple elements can be different types.</li>
</ul>

<h4 id="lists">Lists</h4>
<p>The type of a list is determined by the type of its elements.</p>

<ul>
  <li>A list of type<code class="language-plaintext highlighter-rouge">x</code> is denoted by <code class="language-plaintext highlighter-rouge">[x]</code>.</li>
  <li>This is why lists must contain elements of the same type.</li>
  <li>The length is not encoded in the type.</li>
</ul>

<h2 id="exercises">Exercises</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">:: [Bool]</code></li>
  <li><code class="language-plaintext highlighter-rouge">:: ([[Bool]], [Char])</code>
    <ul>
      <li>As strings are just lists of <code class="language-plaintext highlighter-rouge">Char</code> then you must represent them as such.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">:: [([Bool], Bool)]</code></li>
</ol>

<h1 id="comp105---lecture-10-2"><a href="/UoL/comp105/lectures/2020/11/02/2.html">COMP105 - Lecture 10-2</a></h1>
<h2 id="cracking-the-caesar-cipher">Cracking the Caesar Cipher</h2>
<p>In order to crack a Caesar Cipher you can use the fact that, in English, each letter isnâ€™t used equally. From this you can shift around the letters until you find a shift that fits the distribution of the English language.</p>

<p>As a result of this you should be able to write a program that can guess and decode an English Caesar Shift.</p>

<h3 id="chi-squared-score">Chi-Squared Score</h3>

<p>[\sum^z_{i=a}{\frac{(\text{freq}_i-\text{english}_i)^2}{\text{english}_i}}]</p>

<p>To check if two frequency distributions are similar you can use the chi-squared score. The lower the output the closer the distributions match.</p>

<p>The algorithm will complete the following tasks:</p>

<ul>
  <li>Try all 26 possible shifts</li>
  <li>For each one, compute the letter frequency distribution of the decoded text, and the chi-squared score.</li>
  <li>Use the shift with the lowest chi-squared score.</li>
</ul>

<h3 id="implementation">Implementation</h3>
<p>View <a href="/UoL/assets/COMP105/Lectures/2020-11-02-2.pdf">the slides</a> and <a href="/UoL/assets/COMP105/Lectures/2020-11-02.hs">the source code</a> for the implementation and explanation.</p>

<h1 id="comp105---lecture-10-1"><a href="/UoL/comp105/lectures/2020/11/02/1.html">COMP105 - Lecture 10-1</a></h1>
<h2 id="the-caesar-cipher">The Caesar Cipher</h2>
<p>The Caesar Cipher is a shift method of encoding. This shifts every letter forward by three and wraps around when <code class="language-plaintext highlighter-rouge">z</code> is reached.</p>

<p>There is no particular reason to shift by three and you can shift by any number between zero and 25. Shifting by 13 would be a ROT13.</p>

<h3 id="working-with-characters">Working with Characters</h3>
<p>The <code class="language-plaintext highlighter-rouge">Data.Char</code> package has some useful functions for working with characters.</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">ord</code> function takes a character and returns its ASCII value.</li>
  <li>The <code class="language-plaintext highlighter-rouge">chr</code> function turns an ASCII value into a character.</li>
</ul>

<p>To import a package use the line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import ...
</code></pre></div></div>

<p>using the name of the package you want to import.</p>

<h3 id="implementation">Implementation</h3>

<p>View <a href="/UoL/assets/COMP105/Lectures/2020-11-02-1.pdf">the slides</a> and <a href="/UoL/assets/COMP105/Lectures/2020-11-02.hs">the source code</a> to find the implementation of the Caesar Shift functions.</p>

<h1 id="comp105---lecture-9-3"><a href="/UoL/comp105/lectures/2020/10/29/3.html">COMP105 - Lecture 9-3</a></h1>
<h2 id="mutual-and-multiple-recursion">Mutual and Multiple Recursion</h2>
<h3 id="mutual-recursion">Mutual Recursion</h3>
<p>Mutual recursion is when two functions call each other:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">even'</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">True</span>
<span class="n">even'</span> <span class="n">n</span> <span class="o">=</span> <span class="n">odd'</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">odd'</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">False</span>
<span class="n">odd'</span> <span class="n">n</span> <span class="o">=</span> <span class="n">even'</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>We have to make sure that:</p>

<ul>
  <li>We terminate in a base case.</li>
  <li>We always make progress towards a base case.</li>
</ul>

<p>Mutual recursion is a stylistic choice.</p>

<h2 id="multiple-recursion">Multiple Recursion</h2>
<p>Multiple recursion is when a function makes more than one recursive call in the same recursive rule. This has been see in the <code class="language-plaintext highlighter-rouge">fib</code> function that we made.</p>

<p>Multiple recursion <strong>can</strong> make your code slow as each call makes two additional threads growing the recursive tree exponentially. Additionally the same function is called multiple times with the same parameters.</p>

<pre><code class="language-mermaid">graph TD
A[fib 4] --&gt; B[fib 3]
A --&gt; C[fib 2]
B --&gt; D[fib 2]
B --&gt; E[fib 1]
D --&gt; F[fib 1]
D --&gt; G[fib 0]
C --&gt; H[fib 1]
C --&gt; I[fib 0]
</code></pre>

<h3 id="faster-fib">Faster <code class="language-plaintext highlighter-rouge">fib</code></h3>
<p>Create a <strong>helper function</strong> that computes the Fibonacci list:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fast_fib_help</span> <span class="mi">1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">fast_fib_help</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">:</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="kr">where</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">fast_fib_help</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>This returns the first <code class="language-plaintext highlighter-rouge">n</code> Fibonacci numbers counting down to 0. To turn this into a more presentable list we can use another user facing function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fast_fib</span> <span class="n">n</span> <span class="o">=</span> <span class="n">head</span> <span class="p">(</span><span class="n">fast_fib_help</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>This function is not <strong>multiply recursive</strong> and is therefore must faster to compute.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">multipleThree</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">True</span>
 <span class="n">multipleThree</span> <span class="n">x</span> <span class="o">=</span> <span class="n">two</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	
 <span class="n">one</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">False</span>
 <span class="n">one</span> <span class="n">x</span> <span class="o">=</span> <span class="n">multipleThree</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	
 <span class="n">two</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">False</span>
 <span class="n">two</span> <span class="n">x</span> <span class="o">=</span> <span class="n">one</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">lucas</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">2</span>
 <span class="n">lucas</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
 <span class="n">lucas</span> <span class="n">n</span> <span class="o">=</span> <span class="n">lucas</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">lucas</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-9-2"><a href="/UoL/comp105/lectures/2020/10/29/2.html">COMP105 - Lecture 9-2</a></h1>
<h2 id="recursion-with-multiple-lists">Recursion with Multiple Lists</h2>
<p>Sometimes we want to use recursion on more than one list at a time. The following example adds the elements of two lists together:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add_lists</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">add_lists</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">addlists</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">:</span> <span class="n">addlists</span> <span class="n">xs</span> <span class="n">ys</span>
</code></pre></div></div>

<ul>
  <li>Base cases stop when either of the lists is empty.</li>
  <li>Recursive rule pulls an element form both lists.</li>
</ul>

<p>Another method to implement this, provided that you donâ€™t want to accept lists which donâ€™t have equal length is like the following:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="kt">[]</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">f</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="n">error</span> <span class="s">"Second list is longer"</span>
<span class="n">f</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="n">error</span> <span class="s">"First list is longer"</span>
<span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">:</span> <span class="n">f</span> <span class="n">xs</span> <span class="n">ys</span>
</code></pre></div></div>

<ul>
  <li>This will give an explicit error if they arenâ€™t matching length.</li>
</ul>

<h3 id="splitting-a-list-in-two">Splitting a List in Two</h3>
<p>Other functions can take a list and return a pair of lists:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gt_10</span> <span class="kt">[]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span>
<span class="n">gt_10</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">10</span>	<span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">gt</span><span class="p">,</span> <span class="n">lt</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">otherwise</span>	<span class="o">=</span> <span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="n">x</span><span class="o">:</span><span class="n">lt</span><span class="p">)</span>
	<span class="kr">where</span> <span class="p">(</span><span class="n">gt</span><span class="p">,</span> <span class="n">lt</span><span class="p">)</span> <span class="o">=</span> <span class="n">gt_10</span> <span class="n">xs</span>
</code></pre></div></div>

<p>This will split a list into two lists containing values that are bigger and smaller than 10.</p>

<ul>
  <li>The base case sets up the tuple.</li>
  <li>The recursive rule modifies one of the two lists.</li>
</ul>

<h3 id="zip"><code class="language-plaintext highlighter-rouge">zip</code></h3>
<p><code class="language-plaintext highlighter-rouge">zip</code> takes two lists and returns a list of pairs</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">zip'</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zip'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">zip'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">zip'</span> <span class="n">xs</span> <span class="n">ys</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">multiplyLists</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
 <span class="n">multiplyLists</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
 <span class="n">multiplyLists</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">:</span> <span class="n">multiplyLists</span> <span class="n">xs</span> <span class="n">ys</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">zip3'</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
 <span class="n">zip3'</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">[]</span>
 <span class="n">zip3'</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
 <span class="n">zip3'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">ys</span><span class="p">)</span> <span class="p">(</span><span class="n">z</span><span class="o">:</span><span class="n">zs</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">:</span> <span class="n">zip3'</span> <span class="n">xs</span> <span class="n">ys</span> <span class="n">zs</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-9-1"><a href="/UoL/comp105/lectures/2020/10/29/1.html">COMP105 - Lecture 9-1</a></h1>
<h2 id="where-syntax"><code class="language-plaintext highlighter-rouge">where</code> Syntax</h2>
<p>Sometimes it is useful to bind names across a whole function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">remove_twos</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">remove_twos</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span>	<span class="o">=</span> <span class="n">rest</span>
	<span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span><span class="n">rest</span>
	<span class="kr">where</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">remove_twos</span> <span class="n">xs</span>
</code></pre></div></div>

<p>As the two expressions are in different guards then you canâ€™t use a <code class="language-plaintext highlighter-rouge">let</code> expression.</p>

<p>A general example is:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
	<span class="kr">where</span> 	<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">where</code> comes at the end of a function. Like <code class="language-plaintext highlighter-rouge">let</code> it can bind any number of names</p>

<ul>
  <li>These names are available throughout the function.</li>
  <li>They are not variables.</li>
  <li>You can do pattern matching in <code class="language-plaintext highlighter-rouge">where</code> clauses (and also in <code class="language-plaintext highlighter-rouge">let</code> expressions too).</li>
</ul>

<p>An example of pattern matching:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initials</span> <span class="n">first</span> <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
	<span class="kr">where</span>	<span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">first</span>
			<span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">last</span>
</code></pre></div></div>

<h2 id="let-vs-where"><code class="language-plaintext highlighter-rouge">let</code> v.s. <code class="language-plaintext highlighter-rouge">where</code></h2>
<p><code class="language-plaintext highlighter-rouge">let</code> is an expression.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="kr">in</span> <span class="n">a</span><span class="p">)</span>
<span class="o">&gt;</span> <span class="mi">3</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">where</code> is syntax</p>

<ul>
  <li>One <code class="language-plaintext highlighter-rouge">where</code> clause per function.</li>
  <li>Particularly useful when used with guards.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">remove_twos</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">[]</span>
<span class="n">remove_twos</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span>	<span class="o">=</span> <span class="n">rest</span>
	<span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">x</span><span class="o">:</span><span class="n">rest</span>
	<span class="kr">where</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">remove_twos</span> <span class="n">xs</span>	
</code></pre></div></div>

<p>This means that where has to be joined to a function body and is always bound to that function body.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">func</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">x</span>
     <span class="kr">where</span> 	<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
             <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">-</span> <span class="n">x</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">countTwos</span> <span class="kt">[]</span> 	<span class="o">=</span> <span class="mi">0</span>
 <span class="n">countTwos</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
     <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">rest</span>
     <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">rest</span>
     <span class="kr">where</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">countTwos</span> <span class="n">xs</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-8-2"><a href="/UoL/comp105/lectures/2020/10/27/2.html">COMP105 - Lecture 8-2</a></h1>
<h2 id="list-recursion-examples">List Recursion Examples</h2>
<p>In this section we will be re-implementing the built in functions for operating on lists.</p>

<h3 id="take">take</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">take'</span> <span class="mi">0</span> <span class="n">list</span>	<span class="o">=</span> <span class="kt">[]</span>
<span class="n">take'</span> <span class="n">n</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="kt">[]</span>
<span class="n">take'</span> <span class="n">n</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">take'</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div></div>

<p>With the two base cases the program will end in one of two ways:</p>

<ul>
  <li>We take as many items as we asked for.</li>
  <li>We run out of elements to take.</li>
</ul>

<h3 id="drop">drop</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">drop'</span> <span class="mi">0</span> <span class="n">list</span>	<span class="o">=</span> <span class="n">list</span>
<span class="n">drop'</span> <span class="n">n</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="kt">[]</span> 	<span class="c1">-- could also be an error</span>
<span class="n">drop'</span> <span class="n">n</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">drop'</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">xs</span>
</code></pre></div></div>

<h3 id="elem">elem</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">elem'</span> <span class="n">e</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">False</span>
<span class="n">elem'</span> <span class="n">e</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">e</span> <span class="o">==</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">True</span>
	<span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">elem'</span> <span class="n">e</span> <span class="n">xs</span>
</code></pre></div></div>

<p>This will cycle through every item in the list and will stop and say <code class="language-plaintext highlighter-rouge">True</code> if it is found. If it isnâ€™t found then it will return <code class="language-plaintext highlighter-rouge">False</code>.</p>

<p>This also implements pattern matching and guards in one function.</p>

<h3 id="maximum">maximum</h3>
<p>Maximum will say which is the largest element in a list.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">maximum'</span> <span class="kt">[]</span>	<span class="o">=</span> <span class="n">error</span> <span class="s">"Called with empty list."</span> 
<span class="c1">-- This prints an error with this label</span>
<span class="n">maximum'</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> 
<span class="c1">-- This pattern matches against a list of length 1.</span>
<span class="n">maximum'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span>
	<span class="kr">let</span>
		<span class="n">max_tail</span> <span class="o">=</span> <span class="n">maximum'</span> <span class="n">xs</span>
	<span class="kr">in</span>
		<span class="kr">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">max_tail</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">max_tail</span>
</code></pre></div></div>

<p>This checks from the back of the list and keeps the largest element in the list as <code class="language-plaintext highlighter-rouge">x</code></p>

<h3 id="reverse">reverse</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reverse'</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="kt">[]</span>
<span class="n">reverse'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="n">reverse'</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="c1">-- ++ puts an element onto the tail of a list</span>
</code></pre></div></div>

<h2 id="consuming-more-than-one-element">Consuming More Than One Element</h2>
<h3 id="add_adjacent">add_adjacent</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add_adjacent</span> <span class="kt">[]</span>			<span class="o">=</span> <span class="kt">[]</span>
<span class="n">add_adjacent</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>		<span class="o">=</span> <span class="n">error</span> <span class="s">"Odd number of elements"</span>
<span class="n">add_adjacent</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_adjacent</span> <span class="n">xs</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">add_adjacent</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="add_next">add_next</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add_next</span> <span class="kt">[]</span> 		<span class="o">=</span> <span class="n">error</span> <span class="s">"Not enough elements"</span>
<span class="n">add_next</span> <span class="p">[</span><span class="kr">_</span><span class="p">]</span> 		<span class="o">=</span> <span class="n">error</span> <span class="s">"Not enough elements"</span>
<span class="n">add_next</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span>		<span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">]</span>
<span class="n">add_next</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">:</span> <span class="n">add_next</span> <span class="p">(</span><span class="n">y</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">containsThree</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">False</span>
 <span class="n">containsThree</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>
     <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span>	<span class="o">=</span> <span class="kt">True</span>
     <span class="o">|</span> <span class="n">otherwise</span>	<span class="o">=</span> <span class="n">containsThree</span> <span class="n">xs</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">sumEvenIdx</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="mi">0</span>
 <span class="n">sumEvenIdx</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>		<span class="o">=</span> <span class="n">x</span>
 <span class="c1">-- Required to catch 1 and odd element lists.</span>
 <span class="n">sumEvenIdx</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kr">_</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sumEvenIdx</span> <span class="n">xs</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-8-1"><a href="/UoL/comp105/lectures/2020/10/27/1.html">COMP105 - Lecture 8-1</a></h1>
<h2 id="list-recursion">List Recursion</h2>
<p>Lists have a <strong>head</strong> and a <strong>tail</strong>. We use these command and pattern matching to recurse lists. Generally list recursions use the empty list <code class="language-plaintext highlighter-rouge">[]</code> as part of the base case.</p>

<h3 id="consuming-lists">Consuming Lists</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sum'</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="mi">0</span> 
<span class="n">sum'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum'</span> <span class="n">xs</span>
</code></pre></div></div>

<ul>
  <li>The base case is the empty list.</li>
  <li>The recursive rule breaks the list into its head and tail.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">length'</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="mi">0</span>
<span class="n">length'</span> <span class="p">(</span><span class="kr">_</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length'</span> <span class="n">xs</span>
</code></pre></div></div>

<ul>
  <li>This time the head of the list isnâ€™t used.</li>
</ul>

<h4 id="building-lists">Building Lists</h4>
<p>We can also build lists using recursion.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">down_from</span> <span class="mi">0</span>	<span class="o">=</span> <span class="kt">[]</span>
<span class="n">down_from</span> <span class="n">x</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">down_from</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>This will produce a list counting down from the number provided until  zero is reached.</p>

<h4 id="transforming-lists">Transforming Lists</h4>
<p>If you want to consume and build a list in one go it is called transforming a list.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">square_list</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="kt">[]</span>
<span class="n">square_list</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">:</span> <span class="n">square_list</span> <span class="n">xs</span>
</code></pre></div></div>

<p>This list will square each value and add it recursively onto the list.</p>

<p>The defining feature of transforming lists is that the base case has an input of <code class="language-plaintext highlighter-rouge">[]</code> which is equal to the output of <code class="language-plaintext highlighter-rouge">[]</code>.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">product'</span> <span class="kt">[]</span>		<span class="o">=</span> <span class="mi">1</span>
 <span class="n">product'</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span>	<span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">product'</span> <span class="n">xs</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">upToTen</span> <span class="mi">10</span>	<span class="o">=</span> <span class="mi">10</span>
 <span class="n">upToTen</span> <span class="n">x</span> 	<span class="o">=</span> <span class="n">x</span> <span class="o">:</span> <span class="n">upToTen</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">halveList</span> <span class="kt">[]</span> 		<span class="o">=</span> <span class="kt">[]</span>
 <span class="n">halveList</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> 	<span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="n">halveList</span> <span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-7-2"><a href="/UoL/comp105/lectures/2020/10/26/2.html">COMP105 - Lecture 7-2</a></h1>
<h2 id="more-complex-recursion-and-guards">More Complex Recursion and Guards</h2>
<h3 id="multiple-base-cases">Multiple Base Cases</h3>
<p>Each base case represents a different stopping position:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">isEven</span> <span class="mi">0</span> <span class="o">=</span> <span class="kt">True</span>
<span class="n">isEven</span> <span class="mi">1</span> <span class="o">=</span> <span class="kt">False</span>
<span class="n">isEven</span> <span class="n">n</span> <span class="o">=</span> <span class="n">isEven</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fibonacci</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">fibonacci</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">fibonacci</span> <span class="n">n</span> <span class="o">=</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="multiple-recursive-rules">Multiple Recursive Rules</h3>
<p>More complex recursive functions may have more than one recursive rule.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">evenSum</span> <span class="mi">0</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">evenSum</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">evenSum</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
			<span class="kr">then</span> <span class="n">x</span> <span class="o">+</span> <span class="n">evenSum</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="kr">else</span> <span class="n">evenSum</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>This function adds the even numbers less than the number provided. Hence it only adds <code class="language-plaintext highlighter-rouge">x</code> into the sum when it is even and if not it goes onto the next value.</p>

<p>It is important to make sure that the rules are comprehensive and that no value will crash the program.</p>

<h3 id="guards">Guards</h3>
<p>This is the same function as before but using guards:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">evenSum</span> <span class="n">x</span>
	<span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">evenSum</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">evenSum</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>To use guards, you write your function name and parameters. On the next line, with a pipe, you can write your test and return value:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="n">x</span>
	<span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span>		<span class="o">=</span> <span class="s">"less than five"</span>
	<span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">6</span>		<span class="o">=</span> <span class="s">"bigger than five"</span>
	<span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">5</span>	<span class="o">=</span> <span class="s">"equal to five"</span>
</code></pre></div></div>

<p>They are parsed from top to bottom and should take into account all cases as the interpreter wonâ€™t check for completeness. The word <code class="language-plaintext highlighter-rouge">otherwise</code> will cover all edge cases and make any <strong>partial</strong> function <strong>total</strong>.</p>

<h3 id="guards-vs-pattern-matching">Guards vs. Pattern Matching</h3>
<ul>
  <li>For tests of just equality the best way is to use pattern matching.</li>
  <li>Otherwise guards are to be used as it will save lines written.</li>
</ul>

<h2 id="advice-on-recursion">Advice on Recursion</h2>
<ul>
  <li>When  do you want to stop?
    <ul>
      <li>These are the base cases.</li>
    </ul>
  </li>
  <li>How do you make progress towards a base case?
    <ul>
      <li>How do you make the problem smaller.</li>
      <li>There might be multiple cases to consider.
        <ul>
          <li>These will be the recursive rules.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>What do you  need to do to get to the smaller case?
    <ul>
      <li>These will be the operations that you need to carry out within each rule.</li>
    </ul>
  </li>
</ul>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">sign</span> <span class="n">x</span>
     <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span>		<span class="o">=</span> <span class="s">"negative"</span>
     <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>	<span class="o">=</span> <span class="s">"zero"</span>
     <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> 	<span class="o">=</span> <span class="s">"positive"</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">odd_product</span> <span class="n">x</span>
     <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span>		<span class="o">=</span> <span class="mi">1</span>
     <span class="o">|</span> <span class="n">mod</span> <span class="n">x</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>	<span class="o">=</span> <span class="n">odd_product</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
     <span class="o">|</span> <span class="n">otherwise</span>		<span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">odd_product</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-7-1"><a href="/UoL/comp105/lectures/2020/10/26/1.html">COMP105 - Lecture 7-1</a></h1>
<h2 id="recursion">Recursion</h2>
<p>There is no such thing as a while loop in Haskell so you must use recursion to complete the same task. This links into Assignment 1 as it leans heavily on recursion.</p>

<h3 id="factorial">Factorial</h3>
<p>A recursive function is one that calls itself:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">factorial</span> <span class="n">n</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span>
				<span class="kr">then</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="kr">else</span> <span class="mi">1</span>
</code></pre></div></div>

<p>A recursive function has:</p>

<ul>
  <li>A base case.
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">else</code> case is the base case and is the state where recursion stops.</li>
    </ul>
  </li>
  <li>One or more recursive rules that move us closer to the base case. When the base case is reached then the program will terminate.
    <ul>
      <li>The rule is calling ourself with <code class="language-plaintext highlighter-rouge">n - 1</code>
        <ul>
          <li>This makes progress to the base case as you are making <code class="language-plaintext highlighter-rouge">n</code> smaller and getting closer to 0.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="result-of-factorial">Result of Factorial</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">factorial</span> <span class="mi">4</span>
<span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">factorial</span> <span class="mi">3</span>
<span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">factorial</span> <span class="mi">2</span>
<span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">factorial</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1</span>
<span class="o">&gt;</span> <span class="mi">24</span>
</code></pre></div></div>

<p>A good way to debug smaller iterations is to expand and follow the iterations to find the issue.</p>

<h3 id="factorial-using-pattern-matching">Factorial Using Pattern Matching</h3>
<p>You can use pattern matching to remove the <code class="language-plaintext highlighter-rouge">if</code> in a recursive function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">factorial</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">factorial</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>This is possible as Haskell processes functions from top to bottom. This means that first it will check if the argument matches 1 and if not fall through to the next case.</p>

<p>Another simple example:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">f</span> <span class="mi">3</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">f</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<p>If the pattern matching isnâ€™t exhaustive then you may get an error if an unmapped input is supplied. An <strong>exhaustive function</strong> maps all inputs.</p>

<p>This style of pattern matching is similar to a case select.</p>

<h3 id="base-cases">Base Cases</h3>
<p>Every function must have a base case:</p>

<ul>
  <li>It gives a stopping condition for the recursion.</li>
  <li>It is usually the simplest case.</li>
  <li>You can have more than one base case.</li>
</ul>

<p>Recursion with no base case will never terminate.</p>

<h3 id="comparison-to-imperative-languages">Comparison to Imperative Languages</h3>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">&lt;</span><span class="n">lots</span> <span class="kr">of</span> <span class="n">computation</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>Base cases</strong> are like the <em>stopping condition</em>.</li>
  <li><strong>Recursive rules</strong> do the <em>computation</em>.</li>
  <li>Anything you can do in a loop can be done by recursion but there is no simple way to translate between the two.</li>
</ul>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">smallPrime</span> <span class="mi">2</span> <span class="o">=</span> <span class="kt">True</span>
<span class="n">smallPrime</span> <span class="mi">3</span> <span class="o">=</span> <span class="kt">True</span>
<span class="n">smallPrime</span> <span class="mi">5</span> <span class="o">=</span> <span class="kt">True</span>
<span class="n">smallPrime</span> <span class="mi">7</span> <span class="o">=</span> <span class="kt">True</span>
<span class="n">smallPrime</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">Fase</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">sumUpTo</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
 <span class="n">sumUpTo</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">sumUpTo</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-6-2"><a href="/UoL/comp105/lectures/2020/10/22/2.html">COMP105 - Lecture 6-2</a></h1>
<h2 id="list-comprehensions">List Comprehensions</h2>
<p>List ranges can produce simple arithmetic sequences but list comprehensions can produce more complex lists:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">49</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">81</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
</code></pre></div></div>

<p>By using this you can apply a function to a list and put the result into a list.</p>

<h3 id="predicates">Predicates</h3>
<p>Predicates also add evaluations into the list to limit the results.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">40</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">49</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">81</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
</code></pre></div></div>

<p>This limited the output of the previous example to be strictly greater than 40.</p>

<p>Multiple predicates can be separated by multiple commas:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">40</span><span class="p">,</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">49</span><span class="p">,</span><span class="mi">64</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="in-functions">In Functions</h3>
<p>The body of a function can be a list comprehension:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- This function will print the even values less than a supplied value.</span>

<span class="n">evens_less_than</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>To test each value in a list the following can be applied:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- This function will step through each value in the list `xs`</span>
<span class="c1">-- and apply the function.</span>

<span class="n">lts10</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span> <span class="kr">if</span> <span class="n">x</span>  <span class="o">&lt;</span> <span class="mi">10</span> <span class="kr">then</span> <span class="s">"Yes"</span> <span class="kr">else</span> <span class="s">"No"</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="multiple-variables">Multiple Variables</h3>
<p>You can also use more than one sublist in a list comprehension. This will step though every combination of the two lists and print the operation of the lists. This is similar to a nested for loop.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</code></pre></div></div>

<p>This can also be combined with predicates:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</code></pre></div></div>

<p class="info">Look at <a href="/UoL/assets/COMP105/Lectures/2020-10-22-2.pdf">the slides</a> for more examples of the topics above. This includes examples for some non-trivial functions such as: Factors of a Value, Prime Numbers up to a Value.</p>

<h2 id="lists-of-lists">Lists of Lists</h2>
<ul>
  <li>
    <p>Lists can contain lists provided that they contain the same type. These lists donâ€™t merge but each element in the main list is the sublists:</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>Tuples can also be put in a list provided that they are the same type. This means that the tuples must be:</p>

    <ul>
      <li>Containing the same type.</li>
      <li>Of the same length.</li>
    </ul>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>As a result of the lists containing a list the following happen:</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>

  <span class="o">&gt;</span> <span class="n">head</span> <span class="n">x</span>
  <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

  <span class="o">&gt;</span> <span class="n">tail</span> <span class="n">x</span>
  <span class="o">&gt;</span> <span class="p">[[</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>

  <span class="o">&gt;</span> <span class="n">length</span> <span class="n">x</span>
  <span class="o">&gt;</span> <span class="mi">3</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>As you can have lists of lists you can also nest list comprehensions in lists. An example of this is in <a href="/UoL/assets/COMP105/Lectures/2020-10-22-2.pdf">the slides</a>.</p>
  </li>
</ul>

<h2 id="list-comprehensions-in-other-languages">List Comprehensions in Other Languages</h2>
<p>List comprehensions arose in the functional programming world but they have appeared in imperative languages.</p>

<p>For example in <strong>Python</strong>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s">"A"</span><span class="p">,</span><span class="s">"B"</span><span class="p">,</span><span class="s">"C"</span><span class="p">]]</span>
</code></pre></div></div>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">cubesupto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">|</span> <span class="n">y</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="p">]]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">nospaces</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="sc">' '</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">allpairs</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="p">],</span> <span class="n">b</span> <span class="o">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">y</span><span class="p">]]</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-6-1"><a href="/UoL/comp105/lectures/2020/10/22/1.html">COMP105 - Lecture 6-1</a></h1>
<h2 id="list-ranges">List Ranges</h2>
<p>A list range lets us write a long list in a compact way:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</code></pre></div></div>

<p>If the start is bigger than the end then you will get an empty list. This means you canâ€™t count down in a list in this way. Using <code class="language-plaintext highlighter-rouge">..</code> also works with letters to fill in the letters in between.</p>

<p>To give a step size give the first two elements and then a number to stop before or on:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
</code></pre></div></div>

<p>To count backwards use the a step size of <code class="language-plaintext highlighter-rouge">-1</code>:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">2</span><span class="p">]</span>
<span class="o">&gt;</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="infinite-lists--functions">Infinite Lists &amp; Functions</h3>
<ul>
  <li>
    <p>You can also use this notation to define an infinite list:</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
  <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="o">...</span>
</code></pre></div>    </div>

    <p>This will last forever and you can pass then on to functions. This may be useful if you want some number of elements in an infinite list <code class="language-plaintext highlighter-rouge">take 3 [1..]</code>.</p>
  </li>
  <li>
    <p>To make a list of an an infinitely long value you can use <code class="language-plaintext highlighter-rouge">repeat</code>.</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;</span> <span class="n">repeat</span> <span class="sc">'a'</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>To make a list of an infinite cycle you can use the <code class="language-plaintext highlighter-rouge">cycle</code> function.</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;</span> <span class="n">cycle</span> <span class="s">"abc"</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">onetox</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="n">x</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">evensupto</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">..</span> <span class="n">x</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">countdown</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">..</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-5-2"><a href="/UoL/comp105/lectures/2020/10/21/2.html">COMP105 - Lecture 5-2</a></h1>
<h2 id="lists">Lists</h2>
<p>A list contains any number of items that all have the same type.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">,</span> <span class="sc">'d'</span><span class="p">,</span> <span class="sc">'e'</span><span class="p">]</span>
</code></pre></div></div>

<p>Lists are built with <code class="language-plaintext highlighter-rouge">[]</code> as opposed to tuples which are built with<code class="language-plaintext highlighter-rouge">()</code>.</p>

<ul>
  <li>
    <p>A list can have any number of elements including 0.</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">[]</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>In Haskell lists are linked lists:</p>
    <ul>
      <li>This means that random access is expensive.</li>
      <li>Internally Haskell will walk the entire list to get to the last element.</li>
    </ul>
  </li>
</ul>

<h3 id="strings">Strings</h3>
<p>In Haskell strings are just a list of characters. This means that <code class="language-plaintext highlighter-rouge">['a', 'b', 'c']</code> is equivalent to <code class="language-plaintext highlighter-rouge">"abc"</code>. This has the result of allowing any string operator to  also work on lists.</p>

<h3 id="operators">Operators</h3>
<ul>
  <li>You can join lists together with the <code class="language-plaintext highlighter-rouge">++</code> operator, provided that they have the same type.</li>
  <li>The <code class="language-plaintext highlighter-rouge">!!</code> operator gets a specified element from the list.
    <ul>
      <li>
        <p>Lists are zero indexed.</p>

        <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">0</span>
  <span class="o">&gt;</span> <span class="mi">1</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">head</code> takes the first element of a list.</li>
  <li><code class="language-plaintext highlighter-rouge">tail</code> takes all but the first element of the list.</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">:</code> or the cons operator glues a new head onto an existing list.</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
  <span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</code></pre></div>    </div>

    <ul>
      <li>Any list can be built by consing onto an empty list.</li>
    </ul>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="o">&gt;</span> <span class="sc">'a'</span> <span class="o">:</span> <span class="sc">'b'</span> <span class="o">:</span> <span class="sc">'c'</span> <span class="o">:</span> <span class="kt">[]</span>
  <span class="o">&gt;</span> <span class="s">"abc"</span>
</code></pre></div>    </div>
  </li>
  <li><code class="language-plaintext highlighter-rouge">last</code> gives the last element of the list.</li>
  <li><code class="language-plaintext highlighter-rouge">init</code> gives all elements but the last element.</li>
  <li><code class="language-plaintext highlighter-rouge">length</code> returns the number of elements in the list</li>
</ul>

<p class="info">See <a href="/UoL/assets/COMP105/Lectures/2020-10-21-2.pdf">the slides</a> for more functions.</p>

<h3 id="pattern-matching-example">Pattern Matching Example</h3>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">triple_head</span> <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">x</span>
</code></pre></div></div>

<p>This will name the head of the list <code class="language-plaintext highlighter-rouge">x</code> and the tail <code class="language-plaintext highlighter-rouge">xs</code> as the input is <code class="language-plaintext highlighter-rouge">x</code> consed onto <code class="language-plaintext highlighter-rouge">xs</code>.</p>

<ul>
  <li>It is common for the head to be called <code class="language-plaintext highlighter-rouge">x</code> or another value and for the tail to be called <code class="language-plaintext highlighter-rouge">xs</code> with an <code class="language-plaintext highlighter-rouge">s</code> on the tail.</li>
  <li>If the pattern cannot be matched, such as if the list is empty, then you will get an error.</li>
  <li>
    <p>The wildcard pattern <code class="language-plaintext highlighter-rouge">_</code> wonâ€™t assign a letter if you donâ€™t care about a value.</p>

    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">f</span> <span class="p">(</span><span class="kr">_</span><span class="o">:</span><span class="n">y</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">y</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="exercises">Exercises</h3>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">thricesum</span> <span class="n">list</span> <span class="o">=</span> <span class="n">sum</span> <span class="n">list</span> <span class="o">*</span> <span class="mi">3</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">thirdelement</span> <span class="kr">_</span><span class="o">:</span><span class="kr">_</span><span class="o">:</span><span class="n">x</span><span class="o">:</span><span class="kr">_</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">exclaim</span> <span class="n">string</span> <span class="o">=</span> <span class="sc">'!'</span><span class="o">:</span><span class="n">string</span><span class="o">:</span><span class="sc">'!'</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-5-1"><a href="/UoL/comp105/lectures/2020/10/21/1.html">COMP105 - Lecture 5-1</a></h1>
<h2 id="tuples">Tuples</h2>
<p>A tuples allows us to bind two or more values together:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="s">"A"</span><span class="p">,</span> <span class="s">"few"</span><span class="p">,</span> <span class="s">"words"</span><span class="p">)</span>
<span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s">"six"</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Tuples can have any size but must be at least 2.</li>
  <li>The size should be thought of as being fixed as it is not easy to change  the length of a tuple.</li>
  <li>Tuples can mix types.</li>
</ul>

<h3 id="example-functions">Example Functions</h3>
<h4 id="taking-tuples-as-input">Taking Tuples as Input</h4>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div></div>

<p>This will take a tuple with the elements <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> and will return the first element of the tuple.</p>

<h4 id="returning-tuples-as-output">Returning Tuples as Output</h4>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">max</span> <span class="n">x</span> <span class="n">y</span><span class="p">,</span> <span class="n">min</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="syntax">Syntax</h3>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">g</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</code></pre></div></div>

<p>Both will give the same output but the recommendation is to use the Haskell method instead of always passing tuples.</p>

<h3 id="exercises">Exercises</h3>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">exercise1</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">exercise2</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">exercise3</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-4-2"><a href="/UoL/comp105/lectures/2020/10/19/2.html">COMP105 - Lecture 4-2</a></h1>
<h2 id="let">Let</h2>
<p>Sometimes we want to use the same expression more than once:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<p>The problem of writing out the same equation over again can be solved using the following example:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">let</span> <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span> <span class="kr">in</span> <span class="n">s</span> <span class="o">+</span> <span class="n">sqrt</span> <span class="n">s</span>
</code></pre></div></div>

<h3 id="syntax">Syntax</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let &lt;bindings&gt; in &lt;expression&gt;
</code></pre></div></div>

<p>Where:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;binding&gt;</code> gives names to bindings separated by <code class="language-plaintext highlighter-rouge">;</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">let a = 1; b = a + 1 in a + b</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">&lt;expression&gt;</code> uses those bindings</li>
</ul>

<h3 id="let-vs-variables">Let vs Variables</h3>
<p>A let expression doesnâ€™t create variables:</p>

<ul>
  <li>They are names for particular expressions.</li>
  <li>You cannot change a binding once it has been made.</li>
  <li>They are made for convenience only.</li>
</ul>

<h3 id="let-in-ghci">Let in GHCI</h3>
<p>In GHCI you can write:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>or</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>To define a let for the rest of the session.</p>

<h3 id="let-across-multiple-lines">Let across multiple lines</h3>

<p>Usually  it is clearer to write let across multiple lines:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>
		<span class="kr">in</span>
			<span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span>
</code></pre></div></div>

<p>When splitting across line breaks you donâ€™t need to use <code class="language-plaintext highlighter-rouge">;</code> to separate the bindings.</p>

<h3 id="scope">Scope</h3>
<p>When using let the bindings are only defined within the let function.</p>

<h3 id="examples">Examples</h3>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cylinder</span> <span class="n">r</span> <span class="n">h</span> <span class="o">=</span>
	<span class="kr">let</span> <span class="n">sideArea</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">h</span>
		<span class="n">topArea</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">e</span> <span class="o">**</span> <span class="mi">2</span>
	<span class="kr">in</span> <span class="n">sideArea</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">topArea</span>
</code></pre></div></div>

<h3 id="exercises">Exercises</h3>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">exercise1</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="kr">in</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">exercise2</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">bb</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="n">ccc</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">bb</span> <span class="kr">in</span> <span class="n">ccc</span> <span class="o">*</span>  <span class="n">ccc</span>
</code></pre></div>    </div>
  </li>
</ol>

<h2 id="haskells-layout-rule">Haskellâ€™s Layout Rule</h2>
<p>Each definition at the same level should start on exactly the same column:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="kr">let</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> 
			<span class="n">cc</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span>
		<span class="kr">in</span>
			<span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span>
</code></pre></div></div>

<h3 id="ignoring-the-layout-rule">Ignoring the Layout Rule</h3>
<p>You can ignore the layout rule by using curly braces to separate the bindings.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">let</span> <span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span><span class="p">}</span>
<span class="kr">in</span>
	<span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<h1 id="comp105---lecture-4-1"><a href="/UoL/comp105/lectures/2020/10/19/1.html">COMP105 - Lecture 4-1</a></h1>
<h2 id="if">IF</h2>
<h3 id="differences-between-imperative-and-functional">Differences Between Imperative and Functional</h3>
<p>In imperative languages <code class="language-plaintext highlighter-rouge">if</code> changes the control flow but in functional languages there is no control flow.</p>

<p>Functional <code class="language-plaintext highlighter-rouge">if</code> gives a value that you will return based on a test.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (1==1) then "yes" else "no"
</code></pre></div></div>

<p>Rather than controlling flow, functional <code class="language-plaintext highlighter-rouge">if</code> chooses between two alternatives and is a pure function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f x = (if x &gt; 10 then 1 else 0) + 2
</code></pre></div></div>

<p>The functional <code class="language-plaintext highlighter-rouge">if</code> is more commonly known as the <strong>ternary operator</strong> as it has three arguments.</p>

<h3 id="things-of-note">Things of Note</h3>
<ul>
  <li>For a functional <code class="language-plaintext highlighter-rouge">if</code> both branches much always be present.
    <ul>
      <li>A pure function must always return a value.</li>
    </ul>
  </li>
  <li>Both branches must have the same type.
    <ul>
      <li>This is because Haskell is strongly typed meaning that a single function can only return values of the same type.</li>
    </ul>
  </li>
  <li>Nested <code class="language-plaintext highlighter-rouge">if</code>s are not recommended and there are better ways to complete the same task.</li>
</ul>

<h3 id="structure-of-an-if">Structure of an IF</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if A then B else C
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code> or <code class="language-plaintext highlighter-rouge">C</code> may be anything that can evaluate to a single value. This can be a value itself or another function.</p>

<h3 id="exercises">Exercises</h3>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">between36</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="kr">then</span> <span class="s">"yes"</span> <span class="kr">else</span> <span class="s">"no"</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">min'</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">y</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">max3</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="kr">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="p">(</span><span class="kr">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">z</span> <span class="kr">then</span> <span class="n">y</span> <span class="kr">else</span> <span class="n">z</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-3-2"><a href="/UoL/comp105/lectures/2020/10/14/2.html">COMP105 - Lecture 3-2</a></h1>
<h2 id="defining-custom-functions">Defining Custom Functions</h2>
<p>Functions are defined as such:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">functionName</span><span class="p">][</span><span class="n">arguments</span><span class="p">][</span><span class="o">=</span><span class="p">][</span><span class="n">body</span><span class="p">]</span>
</code></pre></div></div>

<p>Functions and arguments must start with small letters as only types use capitals.</p>

<p>They can be written into a file and loaded into GHCI or compiled for use in a program. An example of a simple function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">addTwo</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">twoInAddTwo</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">2</span>
</code></pre></div></div>

<p class="info">Additional functions are available in <a href="/UoL/assets/COMP105/Lectures/2020-10-14-2.pdf">the slides</a>.</p>

<h2 id="loading-functions">Loading Functions</h2>
<ul>
  <li>To load a functions from a file run GHCI on the file. <code class="language-plaintext highlighter-rouge">$ ghci functions.hs</code></li>
  <li>To reload the current file run <code class="language-plaintext highlighter-rouge">:reload</code> in GHCI.</li>
  <li>To load in a file run <code class="language-plaintext highlighter-rouge">:load</code> and the file-path.</li>
</ul>

<h2 id="comments">Comments</h2>
<p>Single line comments can be written <code class="language-plaintext highlighter-rouge">-- like this</code></p>

<p>Multi-line comments can be written:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">{- Like
   this-}</span>
</code></pre></div></div>

<h2 id="compilation">Compilation</h2>
<p>Instead of running code in the interpreter you can compile it using GHC. To print the output to the <code class="language-plaintext highlighter-rouge">StdOut</code> you can use the two functions <code class="language-plaintext highlighter-rouge">putStrln(show())</code> to convert the output to a string and print that to the <code class="language-plaintext highlighter-rouge">StdOut</code>.</p>

<p>This is part of the IO function-set and wonâ€™t be used again for a while.</p>

<h2 id="exercises">Exercises</h2>
<ol>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
</code></pre></div>    </div>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pythagoras</span> <span class="n">a</span> <span class="n">b</span>  <span class="o">=</span> <span class="n">sqrt</span> <span class="p">(</span><span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div>    </div>
    <ul>
      <li>Must use the float exponentiation operator to allow for floats as a or b.</li>
    </ul>
  </li>
  <li>
    <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">maxFour</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="o">=</span> <span class="n">max</span> <span class="p">(</span><span class="n">max</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">max</span> <span class="n">c</span> <span class="n">d</span><span class="p">)`</span>
</code></pre></div>    </div>
  </li>
</ol>

<h1 id="comp105---lecture-3-1"><a href="/UoL/comp105/lectures/2020/10/14/1.html">COMP105 - Lecture 3-1</a></h1>
<h2 id="functions-and-libraries">Functions and Libraries</h2>
<p>When using Haskell the default library is Prelude.</p>

<p>Haskell uses special syntax for function calls. <code class="language-plaintext highlighter-rouge">min</code> from the Prelude library will work as <code class="language-plaintext highlighter-rouge">min 1 2</code>. This is as functions are called as:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">function</span> <span class="n">name</span><span class="p">][</span><span class="n">space</span><span class="p">][</span><span class="n">arg1</span><span class="p">][</span><span class="n">space</span><span class="p">][</span><span class="n">arg2</span><span class="p">]</span><span class="o">...</span>
</code></pre></div></div>

<p>Additionally in Haskell functions bind tighter than mathematical operators:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mi">28</span> <span class="mi">100</span><span class="o">/</span><span class="mi">4</span>
<span class="mf">7.0</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mi">28</span> <span class="p">(</span><span class="mi">100</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="mf">25.0</span>
</code></pre></div></div>

<h2 id="two-argument-function-syntax">Two Argument Function Syntax</h2>
<p>Functions will two arguments can be infixed by surrounding with back-ticks:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">mod</span> <span class="mi">10</span> <span class="mi">4</span>
<span class="mi">2</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">4</span>
<span class="mi">2</span>
</code></pre></div></div>

<p>For infix functions like <code class="language-plaintext highlighter-rouge">+</code> you can surround them with brackets and use them like a prefix function:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">2</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">1</span>
<span class="mi">2</span>
</code></pre></div></div>

<p class="info">Additional functions are available in <a href="/UoL/assets/COMP105/Lectures/2020-10-14-1.pdf">the slides</a>.</p>

<h1 id="comp105---lecture-2-2"><a href="/UoL/comp105/lectures/2020/10/13/2.html">COMP105 - Lecture 2-2</a></h1>
<h2 id="what-is-functional-programming">What is Functional Programming?</h2>
<p>In a functional programming language <strong>everything is a pure function</strong>.</p>

<ul>
  <li>The program is built out of pure functions.</li>
  <li>Simple functions are combined to build more complex functions.</li>
</ul>

<p>This very different style still allows you to do anything you could have done in an imperative language.</p>

<h2 id="building-functions">Building Functions</h2>
<p><strong>Every</strong> line is built in the form of:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">some</span> <span class="n">other</span> <span class="n">function</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Functions are built up from other functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span>
<span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">i</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">j</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div></div>

<p>A pure functional program is similar to an imperative language where each subroutine only has one line and immediately returns a value.</p>

<h2 id="what-isnt-in-functional-programming">What isnâ€™t in Functional Programming?</h2>
<ul>
  <li>Functional programming has no concept of a variable as variables rely on side effects to operate.</li>
  <li>Functional Programming doesnâ€™t allow loops. This is because loops need variables to operate. Recursion is used instead.
    <ul>
      <li>Anything you can do with a loop can also be done with recursion.</li>
    </ul>
  </li>
  <li>There is no notion of <strong>control flow</strong> as everything is just function application.
    <ul>
      <li>Control flow is the notion that instructions are followed one at a time in a list.</li>
    </ul>
  </li>
</ul>

<p>Functional programming is about passing around your answers.</p>

<h1 id="comp105---lecture-2-1"><a href="/UoL/comp105/lectures/2020/10/13/1.html">COMP105 - Lecture 2-1</a></h1>
<h2 id="what-is-a-pure-function">What is a pure function?</h2>
<p>A function takes inputs and produces outputs. E.g. Input: $x$, Output: $f(x)$</p>

<p>In imperative languages, functions can do much more and are called <em>subroutines</em>.</p>

<p class="info">Every function can be implemented in a subroutine but not all subroutines are functions.</p>

<p>A function maps inputs to outputs, however subroutines can have an effect on the <strong>global state</strong>. The global state is anything that is not within the function, such as modifying global variables, printing, network accessâ€¦</p>

<p class="info">Pure functions only influence the outside world through the return value.</p>

<h2 id="when-does-this-matter">When does this matter?</h2>
<p>When the compiler compiles the code it may want to change the order of the instructions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<p>For a function this will work but for a subroutine it may write out globally and not produce the desired effect.</p>

<p>Using functions makes compiler optimisations, code refactoring, and parallelization easier as the functions can be run in different orders, or concurrently at runtime.</p>

<h2 id="more-rules">More Rules</h2>
<p class="info">Pure functions <strong>always</strong> return a value</p>

<p>This is because pure functions only interact via their return value. If they donâ€™t have a return value they have no effect.</p>

<p class="info">Pure functions must be <strong>deterministic</strong>.</p>

<p>This means that they must return the same value every time, provided that they have the same input.</p>

<p>Determinism allows for logical assumptions such as <code class="language-plaintext highlighter-rouge">f(x) + f(x) == 2 * f(x)</code>. If the function was a subroutine and returned a random value this wouldnâ€™t be the case.</p>

<h2 id="summary">Summary</h2>
<ul>
  <li>Pure Functions
    <ul>
      <li>Are a black box</li>
      <li>Have no side effects</li>
      <li>Are deterministic</li>
    </ul>
  </li>
</ul>

<p>Every pure function is a subroutine, some subroutines are not pure functions.</p>

<h1 id="comp105---lecture-1-2"><a href="/UoL/comp105/lectures/2020/10/12/2.html">COMP105 - Lecture 1-2</a></h1>
<p>Covering dates and logistics of homework and lectures.</p>

<h2 id="learning-outcomes">Learning Outcomes</h2>
<ol>
  <li>Describe functional and imperative languages and the differences between them.
    <ul>
      <li>Weeks 1 - 2</li>
    </ul>
  </li>
  <li>Apply recursion to solve algorithmic tasks.
    <ul>
      <li>Weeks 3 - 4</li>
    </ul>
  </li>
  <li>Apply common functional programming idioms such as map, filter, fold and scan.
    <ul>
      <li>Weeks 5 - 8</li>
    </ul>
  </li>
  <li>Write programs using a functional programming language.
    <ul>
      <li>Weeks 9 - 10</li>
    </ul>
  </li>
</ol>

<h2 id="assessments">Assessments</h2>
<ul>
  <li>Three programming assignments
    <ul>
      <li>Assignment 1 - Recursion - 20%
        <ul>
          <li>Week 4, deadline week 6</li>
        </ul>
      </li>
      <li>Assignment 2 - Functional Programming idioms - 20%
        <ul>
          <li>Week 7, deadline week 9</li>
        </ul>
      </li>
      <li>Assignment 3 Write a full program - 25%
        <ul>
          <li>Week 10, deadline week 12</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>One class test - 25%
    <ul>
      <li>Week 10, deadline week 12</li>
    </ul>
  </li>
  <li>Weekly homework sheets - 10%</li>
</ul>

<h1 id="comp105---lecture-1-1"><a href="/UoL/comp105/lectures/2020/10/12/1.html">COMP105 - Lecture 1-1</a></h1>
<p>Programming languages can be split into imperative and functional. This course will focus on the functional language of Haskell.</p>

<ul>
  <li>Imperative programs tell the computer how to compute the answer.
    <ul>
      <li>Declare variables</li>
      <li>Go around a loop</li>
      <li>Do the same instructions each time</li>
    </ul>
  </li>
  <li>Functional programming languages follow mathematic definitions and focus on recursion. No variables are declared and no explicit loops.
    <ul>
      <li>No variables
        <ul>
          <li>No such thing as a variable in functional programming.</li>
        </ul>
      </li>
      <li>No explicit loops
        <ul>
          <li>using recursive functions.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Functional programming is a style of programming the isnâ€™t dependant on the language that is is written in. Functional programming languages are built to support this style.</p>

<h2 id="course-focus">Course Focus</h2>
<p>The course will focus on functional languages but we will compare the two styles of programming.</p>

<p>Haskell is a pure functional languages as you cannot program in an imperative style easily.</p>

<h2 id="why-functional-languages-are-important">Why Functional Languages are Important</h2>
<ol>
  <li>Their usefulness is increasing
    <ul>
      <li>Multi-core systems and GPUs prefer highly parallel code which functional programs are.</li>
    </ul>
  </li>
  <li>Learning the functional style can make you a better imperative programmer.
    <ul>
      <li>Sometimes the functional style is more appropriate.</li>
      <li>Many imperative languages support functional styles.</li>
    </ul>
  </li>
  <li>Functional programming is a good preparation fo a computer science education.
    <ul>
      <li>Algorithms in CS are often presented in a functional way.</li>
      <li>Functional programming helps you translate the algorithms into functional code.</li>
      <li>The functional paradigm is also used in the analysis of algorithms.</li>
    </ul>
  </li>
</ol>

:ET